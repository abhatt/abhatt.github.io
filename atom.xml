<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/" xmlns:indexing="urn:atom-extension:indexing" indexing:index="no"><access:restriction xmlns:access="http://www.bloglines.com/about/specs/fac-1.0" relationship="deny"/>
  <title>Theory of Computing Blog Aggregator</title>
  <updated>2019-05-28T19:24:22Z</updated>
  <generator uri="http://intertwingly.net/code/venus/">Venus</generator>
  <author>
    <name>Arnab Bhattacharyya, Suresh Venkatasubramanian</name>
    <email>arbhat+cstheoryfeed@gmail.com</email>
  </author>
  <id>http://www.cstheory-feed.org/atom.xml</id>
  <link href="http://www.cstheory-feed.org/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="http://www.cstheory-feed.org/" rel="alternate"/>

  <entry>
    <id>tag:blogger.com,1999:blog-25562705.post-831739446833439686</id>
    <link href="http://aaronsadventures.blogspot.com/feeds/831739446833439686/comments/default" rel="replies" type="application/atom+xml"/>
    <link href="http://www.blogger.com/comment.g?blogID=25562705&amp;postID=831739446833439686" rel="replies" type="text/html"/>
    <link href="http://www.blogger.com/feeds/25562705/posts/default/831739446833439686" rel="edit" type="application/atom+xml"/>
    <link href="http://www.blogger.com/feeds/25562705/posts/default/831739446833439686" rel="self" type="application/atom+xml"/>
    <link href="http://aaronsadventures.blogspot.com/2019/05/individual-notions-of-fairness-you-can.html" rel="alternate" type="text/html"/>
    <title>Individual Notions of Fairness You Can Use</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div style="text-align: center;"><span style="font-size: x-large;"><u>Individual Notions of Fairness You Can Use</u></span></div><br/>Our group at Penn has been thinking about when <i>individual </i>notions of fairness might be practically achievable for awhile, and we have <a href="https://arxiv.org/abs/1905.10660">two</a> <a href="https://arxiv.org/abs/1905.10607">new</a> approaches.<br/><br/><span style="font-size: large;"><u>Background</u>:</span><br/><u>Statistical Fairness</u><br/>I've written about this before, <a href="http://aaronsadventures.blogspot.com/2017/11/between-statistical-and-individual.html">here</a>. But briefly: there are two families of definitions in the fairness in machine learning literature. The first group of definitions, which I call <i>statistical</i> fairness notions, is far and away the most popular. If you want to come up with your own statistical fairness notion, you can follow this recipe:<br/><ol><li>Partition the world into a small number of "protected sub-groups". You will probably be thinking along the lines of race or gender or something similar when you do this.</li><li>Pick your favorite error/accuracy metric for a classifier. This might literally be classification error, or false positive or false negative rate, or positive predictive value, or something else. Lots of options here. </li><li>Ask that this metric be approximately equalized across your protected groups.</li><li>Finally, enjoy your new statistical fairness measure! Congratulations!</li></ol><div>These definitions are far and away the most popular in this literature, in large part (I think) because they are so immediately actionable. Because they are defined as conditions on a small number of expectations, you can easily check whether your classifier is "fair" according to these metrics, and (although there are some interesting computational challenges) go and try and learn classifiers subject to these constraints. </div><div><br/></div><div>Their major problem is related to the reason for their success: they are defined as conditions on a small number of expectations or <i>averages</i> over people, and so they don't promise much to particular individuals. I'll borrow an example from our <a href="https://arxiv.org/abs/1711.05144">fairness gerrymandering</a> paper from a few years ago to put this in sharp relief. Imagine that we are building a system to decide who to incarcerate, and we want to be "fair" with respect to both gender (men and women) and race (green and blue people). We decide that in our scenario, it is the false positives who are harmed (innocent people sent to jail), and so to be fair, we decide should equalize the false positive rate: across men and women, and across greens and blues. But one way to do this is to jail all green men and blue women. This does indeed equalize the false positive rate (at 50%) across all four of the groups we specified, but is cold comfort if you happen to be a green man --- since then you will be jailed with certainty. The problem was our fairness constraint was never a promise to an individual to begin with, just a promise about the average behavior of our classifier over a large group. And although this is a toy example constructed to make a point, things like this happen in real data too. </div><br/><u>Individual Fairness</u><br/>Individual notions of fairness, on the other hand, really do correspond to promises made to individuals. There are at least two kinds of individual fairness definitions that have been proposed: <a href="https://dl.acm.org/citation.cfm?id=2090255">metric fairness</a>, and <a href="http://papers.nips.cc/paper/6355-fairness-in-learning-classic-and-contextual-bandits">weakly meritocratic fairness</a>. Metric fairness proposes that the learner will be handed a <i>task specific similarity metric</i>, and requires that individuals who are close together in the metric should have a similar probability of being classified as positive. Weakly meritocratic fairness, on the other hand, takes the (unknown) labels of an individual as a measure of merit, and requires that individuals who have a higher probability of really having a positive label should have only a higher probability of being classified as positive. This in particular implies that false positive and false negative rates should be equalized <i>across individuals</i>, where now the word <i>rate</i> is averaging over only the randomness of the classifier, not over people. What makes both of these <i>individual</i> notions of fairness is that they impose constraints that bind on all pairs of individuals and not just over averages of people.<br/><br/>Definitions like this have the advantage of strong individual-level semantics, which the statistical definitions don't have. But they also have big problems: for metric fairness, the obvious question is: <i>where does the metric come from</i>? Even granting that fairness should be some Lipschitz condition on a metric, it seems hard to pin down what the metric is, and different people will disagree: coming up with the metric seems to encapsulate a large part of the original problem of defining fairness. For weakly meritocratic fairness, the obvious problem is that we don't know what the labels are. Its possible to do non-trivial things if you make assumptions about the label generating process, but its not at all clear you can do any non-trivial learning subject to this constraint if you don't make strong assumptions.<br/><br/><span style="font-size: large;"><u>Two New Approaches:</u></span><br/>We have two new approaches, building off of metric fairness and weakly meritocratic fairness respectively. Both have the advantages of statistical notions of fairness in that they can be put into practice without making unrealistic assumptions about the data, and without needing to wait on someone to hand us a metric. But they continue to make meaningful promises to individuals.<br/><br/><u>Subjective Individual Fairness</u><br/>Lets start with our variant of metric fairness, which we call subjective individual fairness. (This is joint work with Michael Kearns, our PhD students Chris Jung and Seth Neel, our former PhD student Steven Wu, and Steven's student (our grand student!) Logan Stapleton). The paper is here: <a href="https://arxiv.org/abs/1905.10660">https://arxiv.org/abs/1905.10660</a>. We stick with the premise that "similar people should be treated similarly", and that whether or not it is correct/just/etc., it is at least fair to treat two people the same way, in the sense that we classify them as positive with the same probability. But we don't want to assume anything else.<br/><br/>Suppose I were to create a machine learning fairness panel: I could recruit "AI Ethics" experts, moral philosophers, hyped up consultants, people off the street, toddlers, etc. I would expect that there would be as many different conceptions of fairness as there were people on the panel, and that none of them could precisely quantify what they meant by fairness --- certainly not in the form of a "fairness metric". But I could still ask these people, in particular cases, if they thought it was fair that two particular individuals be treated differently or not.<br/><br/>Of course, I would have no reason to expect that the responses that I got from the different panelists would be consistent with one another --- or possibly even internally consistent (we won't assume, e.g. that the responses satisfy any kind of triangle inequality). Nevertheless, once we fix a data distribution and a group of people who have opinions about fairness, we have a well defined tradeoff we can hope to manage: any classifier we could choose will have both:<br/><ol><li>Some error rate, and</li><li>Some frequency with which it makes a pair of decisions that someone in the group finds unfair. </li></ol><div>We can hope to find classifiers that optimally trade off 1 and 2: note this is a coherent tradeoff even though we haven't forced the people to try and express their conceptions of fairness into some consistent metric. What we show is that you can do this. </div><div><br/></div><div>Specifically, given a set of pairs that we have determined should be treated similarly, there is an <i>oracle efficient </i>algorithm that can find the optimal classifier subject to the constraint that no pair of individuals that has been specified as a constraint should have a substantially different probability of positive classification. Oracle efficiency means that what we can do is reduce the "fair learning" problem to a regular old learning problem, without fairness constraints. If we can solve the regular learning problem, we can also solve the fair learning problem. This kind of fairness constraint also generalizes in the standard way: if you ask your fairness panel about a reasonably small number of pairs, and then solve the in-sample problem subject to these constraints, the classifier you learn will also satisfy the fairness constraints out of sample. And it works: we implement the algorithm and try it out on the COMPAS data set, with fairness constraints that we elicited from 43 human (undergrad) subjects. The interesting thing is that once you have an algorithm like this, it isn't only a tool to create "fair" machine learning models: its also a new instrument to investigate human conceptions of fairness. We already see quite a bit of variation among our 43 subjects in our preliminary experiments. We plan to pursue this direction more going forward.</div><div><br/></div><div><u>Average Individual Fairness</u></div><div>Next, our variant of weakly meritocratic fairness. This is joint work with Michael Kearns and our student Saeed Sharifi. The paper is here: <a href="https://arxiv.org/abs/1905.10607">https://arxiv.org/abs/1905.10607</a>. In certain scenarios, it really does seem tempting to think about fairness in terms of false positive rates. Criminal justice is a great example, in the sense that it is clear that everyone agrees on which outcome they <i>want</i> (they would like to be released from jail), and so the people we are being unfair to really do seem to be the false positives: the people who should have been released from jail, but who were mistakenly incarcerated for longer. So in our "fairness gerrymandering" example above, maybe the problem with thinking about false positive rates wasn't a problem with <i>false positives</i>, but with <i>rates</i>: i.e. the problem was that the word rate averaged over many people, and so it didn't promise <i>you</i> anything. Our idea is to redefine the word rate. </div><div><br/></div><div>In some (but certainly not all) settings, people are subject to not just one, but many classification tasks. For example, consider online advertising: you might be shown thousands of targeted ads each month. Or applying for schools (a process that is centralized in cities like New York): you apply not just to one school, but to many. In situations like this, we can model the fact that we have not just a distribution over people, but also a distribution over (or collection of) problems. </div><div><br/></div><div>Once we have a distribution over problems, we can define the error rate, or false positive rate, or any other rate you like <i>for individuals. </i>It is now sensible to talk about Alice's false positive rate, or Bob's error rate, because rate has been redefined as an average over problems, for a particular individual. So we can now ask for individual fairness notions in the spirit of the statistical notions of fairness we discussed above! We no longer need to define protected groups: we can now ask that the false positive rates, or error rates, be equalized across all pairs of people. </div><div><br/></div><div>It turns out that given a reasonably sized sample of people, and a reasonably sized sample of problems, it is tractable to find the optimal classifier subject to constraints like this in sample, and that these guarantees generalize out of sample. The in-sample algorithm is again an oracle-efficient algorithm, or in other words, a reduction to standard, unconstrained learning. The generalization guarantee here is a little interesting, because now we are talking about simultaneous generalization in two different directions: to people we haven't seen before, and also to problems we haven't seen before. This requires thinking a little bit about what kind of object we are even trying to output: a mapping from new problems to classifiers. The details are in the paper (spoiler --- the mapping is defined by the optimal dual variables for the empirical risk minimization problem): here, I'll just point out that again, the algorithm is practical to implement, and we perform some simple experiments with it. </div><div><br/></div><div><br/></div><br/><br/><br/></div>
    </content>
    <updated>2019-05-28T10:47:00Z</updated>
    <published>2019-05-28T10:47:00Z</published>
    <author>
      <name>Aaron</name>
      <email>noreply@blogger.com</email>
      <uri>http://www.blogger.com/profile/09952936358739421126</uri>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-25562705</id>
      <category term="game theory"/>
      <category term="news"/>
      <author>
        <name>Aaron</name>
        <email>noreply@blogger.com</email>
        <uri>http://www.blogger.com/profile/09952936358739421126</uri>
      </author>
      <link href="http://aaronsadventures.blogspot.com/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/>
      <link href="http://www.blogger.com/feeds/25562705/posts/default" rel="self" type="application/atom+xml"/>
      <link href="http://aaronsadventures.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/>
      <link href="http://www.blogger.com/feeds/25562705/posts/default?start-index=26&amp;max-results=25" rel="next" type="application/atom+xml"/>
      <title>Adventures in Computation</title>
      <updated>2019-05-28T10:47:35Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://cstheory-jobs.org/2019/05/28/one-or-more-phd-stipends-in-machine-learning-for-wireless-communications-8-19015-at-department-of-electronic-systems-aalborg-university-apply-by-june-10-2019/</id>
    <link href="https://cstheory-jobs.org/2019/05/28/one-or-more-phd-stipends-in-machine-learning-for-wireless-communications-8-19015-at-department-of-electronic-systems-aalborg-university-apply-by-june-10-2019/" rel="alternate" type="text/html"/>
    <title>One or more PhD Stipends in Machine Learning for Wireless Communications (8-19015) at Department of Electronic Systems, Aalborg University (apply by June 10, 2019)</title>
    <summary>WINDMILL Early Stage Researcher 9: Optimizing URLLC metadata/data flows using machine learning Aalborg University is seeking to hire an Early Stage Researcher (ESR) to join the Marie Skłodowska-Curie Innovative Training Network on “Integrating Wireless Communication ENgineering and MachIne Learning”.(WindMill). More details are included https://windmill-itn.eu/ Website: https://www.stillinger.aau.dk/vis-stilling/?vacancy=1029705 Email: edc@es.aau.dk</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>WINDMILL Early Stage Researcher 9: Optimizing URLLC metadata/data flows using machine learning</p>
<p>Aalborg University is seeking to hire an Early Stage Researcher (ESR) to join the Marie Skłodowska-Curie Innovative Training Network on “Integrating Wireless Communication ENgineering and MachIne Learning”.(WindMill). More details are included <a href="https://windmill-itn.eu/">https://windmill-itn.eu/</a></p>
<p>Website: <a href="https://www.stillinger.aau.dk/vis-stilling/?vacancy=1029705">https://www.stillinger.aau.dk/vis-stilling/?vacancy=1029705</a><br/>
Email: edc@es.aau.dk</p></div>
    </content>
    <updated>2019-05-28T09:14:08Z</updated>
    <published>2019-05-28T09:14:08Z</published>
    <category term="Uncategorized"/>
    <author>
      <name>shacharlovett</name>
    </author>
    <source>
      <id>https://cstheory-jobs.org</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://cstheory-jobs.org/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://cstheory-jobs.org" rel="alternate" type="text/html"/>
      <link href="https://cstheory-jobs.org/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://cstheory-jobs.org/?pushpress=hub" rel="hub" type="text/html"/>
      <title>Theoretical Computer Science Jobs</title>
      <updated>2019-05-28T19:21:28Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://cstheory-jobs.org/2019/05/28/one-or-more-phd-stipends-in-machine-learning-for-wireless-communications-8-19014-at-department-of-electronic-systems-aalborg-university-apply-by-june-10-2019/</id>
    <link href="https://cstheory-jobs.org/2019/05/28/one-or-more-phd-stipends-in-machine-learning-for-wireless-communications-8-19014-at-department-of-electronic-systems-aalborg-university-apply-by-june-10-2019/" rel="alternate" type="text/html"/>
    <title>One or more PhD Stipends in Machine Learning for Wireless Communications (8-19014) at Department of Electronic Systems, Aalborg University (apply by June 10, 2019)</title>
    <summary>Aalborg University is seeking to hire an Early Stage Researcher (ESR) to join the Marie Skłodowska-Curie Innovative Training Network on “Integrating Wireless Communication ENgineering and MachIne Learning”.(WindMill). More details are included https://windmill-itn.eu/ Website: https://www.stillinger.aau.dk/vis-stilling/?vacancy=1029703 Email: edc@es.aau.dk</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Aalborg University is seeking to hire an Early Stage Researcher (ESR) to join the Marie Skłodowska-Curie Innovative Training Network on “Integrating Wireless Communication ENgineering and MachIne Learning”.(WindMill). More details are included <a href="https://windmill-itn.eu/">https://windmill-itn.eu/</a></p>
<p>Website: <a href="https://www.stillinger.aau.dk/vis-stilling/?vacancy=1029703">https://www.stillinger.aau.dk/vis-stilling/?vacancy=1029703</a><br/>
Email: edc@es.aau.dk</p></div>
    </content>
    <updated>2019-05-28T09:11:31Z</updated>
    <published>2019-05-28T09:11:31Z</published>
    <category term="Uncategorized"/>
    <author>
      <name>shacharlovett</name>
    </author>
    <source>
      <id>https://cstheory-jobs.org</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://cstheory-jobs.org/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://cstheory-jobs.org" rel="alternate" type="text/html"/>
      <link href="https://cstheory-jobs.org/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://cstheory-jobs.org/?pushpress=hub" rel="hub" type="text/html"/>
      <title>Theoretical Computer Science Jobs</title>
      <updated>2019-05-28T19:21:27Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.11166</id>
    <link href="http://arxiv.org/abs/1905.11166" rel="alternate" type="text/html"/>
    <title>Hierarchy of Transportation Network Parameters and Hardness Results</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Blum:Johannes.html">Johannes Blum</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.11166">PDF</a><br/><b>Abstract: </b>The graph parameters highway dimension and skeleton dimension were introduced
to capture the properties of transportation networks. As many important
optimization problems like Travelling Salesperson, Steiner Tree or $k$-Center
arise in such networks, it is worthwhile to study them on graphs of bounded
highway or skeleton dimension.
</p>
<p>We investigate the relationships between mentioned parameters and how they
are related to other important graph parameters that have been applied
successfully to various optimization problems. We show that the skeleton
dimension is incomparable to any of the parameters distance to linear forest,
bandwidth, treewidth and highway dimension and hence, it is worthwhile to study
mentioned problems also on graphs of bounded skeleton dimension. Moreover, we
prove that the skeleton dimension is upper bounded by the max leaf number and
that for any graph on at least three vertices there are edge weights such that
both parameters are equal.
</p>
<p>Then we show that computing the highway dimension according to most recent
definition is NP-hard, which answers an open question stated by Feldmann et al.
Finally we prove that on graphs $G=(V,E)$ of skeleton dimension
$\mathcal{O}(\log^2 \vert V \vert)$ it is NP-hard to approximate the $k$-Center
problem within a factor less than $2$.
</p></div>
    </summary>
    <updated>2019-05-28T01:21:14Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.11092</id>
    <link href="http://arxiv.org/abs/1905.11092" rel="alternate" type="text/html"/>
    <title>A Rate-Distortion Framework for Explaining Neural Network Decisions</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Jan Macdonald, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/w/W=auml=ldchen:Stephan.html">Stephan Wäldchen</a>, Sascha Hauch, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kutyniok:Gitta.html">Gitta Kutyniok</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.11092">PDF</a><br/><b>Abstract: </b>We formalise the widespread idea of interpreting neural network decisions as
an explicit optimisation problem in a rate-distortion framework. A set of input
features is deemed relevant for a classification decision if the expected
classifier score remains nearly constant when randomising the remaining
features. We discuss the computational complexity of finding small sets of
relevant features and show that the problem is complete for
$\mathsf{NP}^\mathsf{PP}$, an important class of computational problems
frequently arising in AI tasks. Furthermore, we show that it even remains
$\mathsf{NP}$-hard to only approximate the optimal solution to within any
non-trivial approximation factor. Finally, we consider a continuous problem
relaxation and develop a heuristic solution strategy based on assumed density
filtering for deep ReLU neural networks. We present numerical experiments for
two image classification data sets where we outperform established methods in
particular for sparse explanations of neural network decisions.
</p></div>
    </summary>
    <updated>2019-05-28T01:20:48Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10902</id>
    <link href="http://arxiv.org/abs/1905.10902" rel="alternate" type="text/html"/>
    <title>Engineering Kernelization for Maximum Cut</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Damir Ferizovic, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Hespe:Demian.html">Demian Hespe</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lamm:Sebastian.html">Sebastian Lamm</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/Mnich:Matthias.html">Matthias Mnich</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Schulz:Christian.html">Christian Schulz</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Strash:Darren.html">Darren Strash</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10902">PDF</a><br/><b>Abstract: </b>Kernelization is a general theoretical framework for preprocessing instances
of NP-hard problems into (generally smaller) instances with bounded size, via
the repeated application of data reduction rules. For the fundamental Max Cut
problem, kernelization algorithms are theoretically highly efficient for
various parameterizations. However, the efficacy of these reduction rules in
practice---to aid solving highly challenging benchmark instances to
optimality---remains entirely unexplored.
</p>
<p>We engineer a new suite of efficient data reduction rules that subsume most
of the previously published rules, and demonstrate their significant impact on
benchmark data sets, including synthetic instances, and data sets from the VLSI
and image segmentation application domains. Our experiments reveal that current
state-of-the-art solvers can be sped up by up to multiple orders of magnitude
when combined with our data reduction rules. On social and biological networks
in particular, kernelization enables us to solve four instances that were
previously unsolved in a ten-hour time limit with state-of-the-art solvers;
three of these instances are now solved in less than two seconds.
</p></div>
    </summary>
    <updated>2019-05-28T01:22:29Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10867</id>
    <link href="http://arxiv.org/abs/1905.10867" rel="alternate" type="text/html"/>
    <title>Regular resolution for CNF of bounded incidence treewidth with few long clauses</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Andrea Cali, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/r/Razgon:Igor.html">Igor Razgon</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10867">PDF</a><br/><b>Abstract: </b>We demonstrate that Regular Resolution is FPT for two restricted families of
CNFs of bounded incidence treewidth. The first includes CNFs having at most $p$
clauses whose removal results in a CNF of primal treewidth at most $k$. The
parameters we use in this case are $p$ and $k$. The second class includes CNFs
of bounded one-sided (incidence) treewdth, a new parameter generalizing both
primal treewidth and incidence pathwidth. The parameter we use in this case is
the one-sided treewidth.
</p></div>
    </summary>
    <updated>2019-05-28T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10833</id>
    <link href="http://arxiv.org/abs/1905.10833" rel="alternate" type="text/html"/>
    <title>Improved Distributed Approximations for Minimum-Weight Two-Edge-Connected Spanning Subgraph</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/d/Dory:Michal.html">Michal Dory</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Ghaffari:Mohsen.html">Mohsen Ghaffari</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10833">PDF</a><br/><b>Abstract: </b>The minimum-weight $2$-edge-connected spanning subgraph (2-ECSS) problem is a
natural generalization of the well-studied minimum-weight spanning tree (MST)
problem, and it has received considerable attention in the area of network
design. The latter problem asks for a minimum-weight subgraph with an edge
connectivity of $1$ between each pair of vertices while the former strengthens
this edge-connectivity requirement to $2$. Despite this resemblance, the 2-ECSS
problem is considerably more complex than MST. While MST admits a linear-time
centralized exact algorithm, 2-ECSS is NP-hard and the best known centralized
approximation algorithm for it (that runs in polynomial time) gives a
$2$-approximation.
</p>
<p>In this paper, we give a deterministic distributed algorithm with round
complexity of $\widetilde{O}(D+\sqrt{n})$ that computes a
$(5+\epsilon)$-approximation of 2-ECSS, for any constant $\epsilon&gt;0$. Up to
logarithmic factors, this complexity matches the
$\widetilde{\Omega}(D+\sqrt{n})$ lower bound that can be derived from Das Sarma
et al. [STOC'11], as shown by Censor-Hillel and Dory [OPODIS'17]. Our result is
the first distributed constant approximation for 2-ECSS in the nearly optimal
time and it improves on a recent randomized algorithm of Dory [PODC'18], which
achieved an $O(\log n)$-approximation in $\widetilde{O}(D+\sqrt{n})$ rounds.
</p>
<p>We also present an alternative algorithm for $O(\log n)$-approximation, whose
round complexity is linear in the low-congestion shortcut parameter of the
network, following a framework introduced by Ghaffari and Haeupler [SODA'16].
This algorithm has round complexity $\widetilde{O}(D+\sqrt{n})$ in worst-case
networks but it provably runs much faster in many well-behaved graph families
of interest. For instance, it runs in $\widetilde{O}(D)$ time in planar
networks and those with bounded genus, bounded path-width or bounded
tree-width.
</p></div>
    </summary>
    <updated>2019-05-28T01:30:56Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10825</id>
    <link href="http://arxiv.org/abs/1905.10825" rel="alternate" type="text/html"/>
    <title>Phase Transitions and Cyclic Phenomena in Bandits with Switching Constraints</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Simchi=Levi:David.html">David Simchi-Levi</a>, Yunzong Xu <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10825">PDF</a><br/><b>Abstract: </b>We consider the classical stochastic multi-armed bandit problem with a
constraint on the total cost incurred by switching between actions. We prove
matching upper and lower bounds on regret and provide near-optimal algorithms
for this problem. Surprisingly, we discover phase transitions and cyclic
phenomena of the optimal regret. That is, we show that associated with the
multi-armed bandit problem, there are phases defined by the number of arms and
switching costs, where the regret upper and lower bounds in each phase remain
the same and drop significantly between phases. The results enable us to fully
characterize the trade-off between regret and incurred switching cost in the
stochastic multi-armed bandit problem, contributing new insights to this
fundamental problem. Under the general switching cost structure, the results
reveal a deep connection between bandit problems and graph traversal problems,
such as the shortest Hamiltonian path problem.
</p></div>
    </summary>
    <updated>2019-05-28T01:29:28Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10820</id>
    <link href="http://arxiv.org/abs/1905.10820" rel="alternate" type="text/html"/>
    <title>Geodesics in persistence diagram space</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/c/Chowdhury:Samir.html">Samir Chowdhury</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10820">PDF</a><br/><b>Abstract: </b>It is known that for a variety of choices of metrics, including the standard
bottleneck distance, the space of persistence diagrams admits geodesics.
Typically these existence results produce geodesics that have the form of a
convex combination. More specifically, given two persistence diagrams and a
choice of metric, one obtains a bijection realizing the distance between the
diagrams, and uses this bijection to linearly interpolate from one diagram to
another. We prove that for several families of metrics, every geodesic in
persistence diagram space arises as such a convex combination. For certain
other choices of metrics, we explicitly construct infinite families of
geodesics that cannot have this form.
</p></div>
    </summary>
    <updated>2019-05-28T01:31:34Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Geometry"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CG" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Geometry (cs.CG) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CG updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10809</id>
    <link href="http://arxiv.org/abs/1905.10809" rel="alternate" type="text/html"/>
    <title>Minimum Age TDMA Scheduling</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kuo:Tung=Wei.html">Tung-Wei Kuo</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10809">PDF</a><br/><b>Abstract: </b>We consider a transmission scheduling problem in which multiple systems
receive update information through a shared Time Division Multiple Access
(TDMA) channel. To provide timely delivery of update information, the problem
asks for a schedule that minimizes the overall age of information. We call this
problem the Min-Age problem. This problem is first studied by He \textit{et
al.} [IEEE Trans. Inform. Theory, 2018], who identified several special cases
where the problem can be solved optimally in polynomial time. Our contribution
is threefold. First, we introduce a new job scheduling problem called the
Min-WCS problem, and we prove that, for any constant $r \geq 1$, every
$r$-approximation algorithm for the Min-WCS problem can be transformed into an
$r$-approximation algorithm for the Min-Age problem. Second, we give a
randomized 2.733-approximation algorithm and a dynamic-programming-based exact
algorithm for the Min-WCS problem. Finally, we prove that the Min-Age problem
is NP-hard.
</p></div>
    </summary>
    <updated>2019-05-28T01:23:37Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10775</id>
    <link href="http://arxiv.org/abs/1905.10775" rel="alternate" type="text/html"/>
    <title>Deterministic Distributed Dominating Set Approximation in the CONGEST Model</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Janosch Deurer, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kuhn:Fabian.html">Fabian Kuhn</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/Maus:Yannic.html">Yannic Maus</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10775">PDF</a><br/><b>Abstract: </b>We develop deterministic approximation algorithms for the minimum dominating
set problem in the CONGEST model with an almost optimal approximation
guarantee. For $\epsilon&gt;1/{\text{{poly}}}\log \Delta$ we obtain two algorithms
with approximation factor $(1+\epsilon)(1+\ln (\Delta+1))$ and with runtimes
$2^{O(\sqrt{\log n \log\log n})}$ and $O(\Delta\cdot\text{poly}\log \Delta
+\text{poly}\log \Delta \log^{*} n)$, respectively. Further we show how
dominating set approximations can be deterministically transformed into a
connected dominating set in the \CONGEST model while only increasing the
approximation guarantee by a constant factor. This results in a deterministic
$O(\log \Delta)$-approximation algorithm for the minimum connected dominating
set with time complexity
</p>
<p>$2^{O(\sqrt{\log n \log\log n})}$.
</p></div>
    </summary>
    <updated>2019-05-28T01:29:56Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10747</id>
    <link href="http://arxiv.org/abs/1905.10747" rel="alternate" type="text/html"/>
    <title>On the monotone complexity of the shift operator</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Sergeev:Igor_S=.html">Igor S. Sergeev</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10747">PDF</a><br/><b>Abstract: </b>We show that the complexity of minimal monotone circuits implementing a
monotone version of the shift operator on $n$ boolean inputs is $\Theta(n\log
n)$.
</p></div>
    </summary>
    <updated>2019-05-28T01:21:35Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10716</id>
    <link href="http://arxiv.org/abs/1905.10716" rel="alternate" type="text/html"/>
    <title>Algorithmic and geometric aspects of data depth with focus on $\beta$-skeleton depth</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Shahsavarifar:Rasoul.html">Rasoul Shahsavarifar</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10716">PDF</a><br/><b>Abstract: </b>The statistical rank tests play important roles in univariate non-parametric
data analysis. If one attempts to generalize the rank tests to a multivariate
case, the problem of defining a multivariate order will occur. It is not clear
how to define a multivariate order or statistical rank in a meaningful way. One
approach to overcome this problem is to use the notion of data depth which
measures the centrality of a point with respect to a given data set. In other
words, a data depth can be applied to indicate how deep a point is located with
respect to a given data set. Using data depth, a multivariate order can be
defined by ordering the data points according to their depth values. Various
notions of data depth have been introduced over the last decades. In this
thesis, we discuss three depth functions: two well-known depth functions
halfspace depth and simplicial depth, and one recently defined depth function
named as $\beta$-skeleton depth, $\beta\geq 1$. The $\beta$-skeleton depth is
equivalent to the previously defined spherical depth and lens depth when
$\beta=1$ and $\beta=2$, respectively. Our main focus in this thesis is to
explore the geometric and algorithmic aspects of $\beta$-skeleton depth.
</p></div>
    </summary>
    <updated>2019-05-28T01:31:51Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Geometry"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CG" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Geometry (cs.CG) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CG updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10682</id>
    <link href="http://arxiv.org/abs/1905.10682" rel="alternate" type="text/html"/>
    <title>Counting Homomorphisms Modulo a Prime Number</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Amirhossein Kazeminia, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Bulatov:Andrei_A=.html">Andrei A. Bulatov</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10682">PDF</a><br/><b>Abstract: </b>Counting problems in general and counting graph homomorphisms in particular
have numerous applications in combinatorics, computer science, statistical
physics, and elsewhere. One of the most well studied problems in this area is
#GraphHom(H) --- the problem of finding the number of homomorphisms from a
given graph G to the graph H. Not only the complexity of this basic problem is
known, but also of its many variants for digraphs, more general relational
structures, graphs with weights, and others.
</p>
<p>In this paper we consider a modification of #GraphHom(H), the #_p GraphHom(H)
problem, p a prime number: Given a graph G, find the number of homomorphisms
from G to H modulo p. In a series of papers Faben and Jerrum, and Goebel et al.
determined the complexity of #_2 GraphHom(H) in the case H (or, in fact, a
certain graph derived from H) is square-free, that is, does not contain a
4-cycle. Also, Goebel et al. found the complexity of #_p GraphHom(H) for an
arbitrary prime p when H is a tree. Here we extend the above result to show
that the #_p GraphHom(H) problem is #_p P-hard whenever the derived graph
associated with H is square-free and is not a star, which completely classifies
the complexity of #_p GraphHom(H) for square-free graphs H.
</p></div>
    </summary>
    <updated>2019-05-28T01:21:40Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10670</id>
    <link href="http://arxiv.org/abs/1905.10670" rel="alternate" type="text/html"/>
    <title>Subgraph Isomorphism on Graph Classes that Exclude a Substructure</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Bodlaender:Hans_L=.html">Hans L. Bodlaender</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Hanaka:Tesshu.html">Tesshu Hanaka</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kobayashi:Yasuaki.html">Yasuaki Kobayashi</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kobayashi:Yusuke.html">Yusuke Kobayashi</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/o/Okamoto:Yoshio.html">Yoshio Okamoto</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/o/Otachi:Yota.html">Yota Otachi</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/z/Zanden:Tom_C=_van_der.html">Tom C. van der Zanden</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10670">PDF</a><br/><b>Abstract: </b>We study Subgraph Isomorphism on graph classes defined by a fixed forbidden
graph. Although there are several ways for forbidding a graph, we observe that
it is reasonable to focus on the minor relation since other well-known
relations lead to either trivial or equivalent problems. When the forbidden
minor is connected, we present a near dichotomy of the complexity of Subgraph
Isomorphism with respect to the forbidden minor, where the only unsettled case
is $P_{5}$, the path of five vertices. We then also consider the general case
of possibly disconnected forbidden minors. We show fixed-parameter tractable
cases and randomized XP-time solvable cases parameterized by the size of the
forbidden minor $H$. We also show that by slightly generalizing the tractable
cases, the problem becomes NP-complete. All unsettle cases are equivalent to
$P_{5}$ or the disjoint union of two $P_{5}$'s. As a byproduct, we show that
Subgraph Isomorphism is fixed-parameter tractable parameterized by vertex
integrity. Using similar techniques, we also observe that Subgraph Isomorphism
is fixed-parameter tractable parameterized by neighborhood diversity.
</p></div>
    </summary>
    <updated>2019-05-28T01:23:41Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10592</id>
    <link href="http://arxiv.org/abs/1905.10592" rel="alternate" type="text/html"/>
    <title>Evacuating Two Robots from a Disk: A Second Cut</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/d/Disser:Yann.html">Yann Disser</a>, Sören Schmitt <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10592">PDF</a><br/><b>Abstract: </b>We present an improved algorithm for the problem of evacuating two robots
from the unit disk via an unknown exit on the boundary. Robots start at the
center of the disk, move at unit speed, and can only communicate locally. Our
algorithm improves previous results by Brandt et al. [CIAC'17] by introducing a
second detour through the interior of the disk. This allows for an improved
evacuation time of $5.6234$. The best known lower bound of $5.255$ was shown by
Czyzowicz et al. [CIAC'15].
</p></div>
    </summary>
    <updated>2019-05-28T01:28:51Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10510</id>
    <link href="http://arxiv.org/abs/1905.10510" rel="alternate" type="text/html"/>
    <title>Resisting Adversarial Attacks by $k$-Winners-Take-All</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/x/Xiao:Chang.html">Chang Xiao</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/z/Zhong:Peilin.html">Peilin Zhong</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/z/Zheng:Changxi.html">Changxi Zheng</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10510">PDF</a><br/><b>Abstract: </b>We propose a simple change to the current neural network structure for
defending against gradient-based adversarial attacks. Instead of using popular
activation functions (such as ReLU), we advocate the use of
$k$-Winners-Take-All ($k$-WTA) activation, a $C^0$ discontinuous function that
purposely invalidates the neural network model's gradient at densely
distributed input data points. Our proposal is theoretically rationalized. We
show why the discontinuities in $k$-WTA networks can largely prevent
gradient-based search of adversarial examples and why they at the same time
remain innocuous to the network training. This understanding is also
empirically backed. Even without notoriously expensive adversarial training,
the robustness performance of our networks is comparable to conventional ReLU
networks optimized by adversarial training. Furthermore, after also optimized
through adversarial training, our networks outperform the state-of-the-art
methods under white-box attacks on various datasets that we experimented with.
</p></div>
    </summary>
    <updated>2019-05-28T01:23:16Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10477</id>
    <link href="http://arxiv.org/abs/1905.10477" rel="alternate" type="text/html"/>
    <title>Efficiently Estimating Erdos-Renyi Graphs with Node Differential Privacy</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Sealfon:Adam.html">Adam Sealfon</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/u/Ullman:Jonathan.html">Jonathan Ullman</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10477">PDF</a><br/><b>Abstract: </b>We give a simple, computationally efficient, and node-differentially-private
algorithm for estimating the parameter of an Erdos-Renyi graph---that is,
estimating p in a G(n,p)---with near-optimal accuracy. Our algorithm nearly
matches the information-theoretically optimal exponential-time algorithm for
the same problem due to Borgs et al. (FOCS 2018). More generally, we give an
optimal, computationally efficient, private algorithm for estimating the
edge-density of any graph whose degree distribution is concentrated on a small
interval.
</p></div>
    </summary>
    <updated>2019-05-28T01:22:04Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10469</id>
    <link href="http://arxiv.org/abs/1905.10469" rel="alternate" type="text/html"/>
    <title>Meshfree Methods on Manifolds for Hydrodynamic Flows on Curved Surfaces: A Generalized Moving Least-Squares (GMLS) Approach</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Gross:B=_J=.html">B. J. Gross</a>, N. Trask, P. Kuberry, P. J. Atzberger <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10469">PDF</a><br/><b>Abstract: </b>We utilize generalized moving least squares (GMLS) to develop meshfree
techniques for discretizing hydrodynamic flow problems on manifolds. We use
exterior calculus to formulate incompressible hydrodynamic equations in the
Stokesian regime and handle the divergence-free constraints via a generalized
vector potential. This provides less coordinate-centric descriptions and
enables the development of efficient numerical methods and a splitting scheme
of the fourth-order governing equations in terms of two second-order elliptic
operators. We show our methods have high-order convergence rates for the metric
and other geometric quantities of the manifold, for the truncation errors of
exterior calculus operators, and for the solution errors of the Stokes problem
for hydrodynamic flows on curved surfaces. Our approaches also may be utilized
to develop high-order solvers for other scalar-valued and vector-valued
problems on manifolds.
</p></div>
    </summary>
    <updated>2019-05-28T01:31:40Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Geometry"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CG" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Geometry (cs.CG) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CG updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10415</id>
    <link href="http://arxiv.org/abs/1905.10415" rel="alternate" type="text/html"/>
    <title>Quantum-inspired algorithms in practice</title>
    <feedworld_mtime>1559001600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/a/Arrazola:Juan_Miguel.html">Juan Miguel Arrazola</a>, Alain Delgado, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Bardhan:Bhaskar_Roy.html">Bhaskar Roy Bardhan</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lloyd:Seth.html">Seth Lloyd</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10415">PDF</a><br/><b>Abstract: </b>We study the practical performance of quantum-inspired algorithms for
recommendation systems and linear systems of equations. These algorithms were
shown to have an exponential asymptotic speedup compared to previously known
classical methods for problems involving low-rank matrices, but with complexity
bounds that exhibit a hefty polynomial overhead compared to quantum algorithms.
This raised the question of whether these methods were actually useful in
practice. We conduct a theoretical analysis aimed at identifying their
computational bottlenecks, then implement and benchmark the algorithms on a
variety of problems, including applications to portfolio optimization and movie
recommendations. On the one hand, our analysis reveals that the performance of
these algorithms is better than the theoretical complexity bounds would
suggest. On the other hand, their performance degrades noticeably as the rank
and condition number of the input matrix are increased. Overall, our results
indicate that quantum-inspired algorithms can perform well in practice but only
provided that stringent conditions are met: low rank, low condition number, and
very large dimension of the input matrix. By contrast, practical datasets are
often sparse and high-rank, precisely the type that can be handled by quantum
algorithms.
</p></div>
    </summary>
    <updated>2019-05-28T01:29:06Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-28T01:30:00Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality</id>
    <link href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html" rel="alternate" type="text/html"/>
    <title>Shattering and quasipolynomiality</title>
    <summary>An inadequately-explained phenomenon in computational complexity theory is that there are so few natural candidates for -intermediate problems, problems in but neither in nor -complete. Of course, if there are none, and the dichotomy theorem implies that there are no intermediate Boolean constraint satisfaction problems. But there are a lot of other types of problems in , and a theorem of Ladner1 shows that there should be an infinite hierarchy of degrees of hardness within . So where are all the members of this hierarchy, and why are they so shy? Ladner, Richard (1975), “On the structure of polynomial time reducibility”, J. ACM 22 (1): 155–171. ↩</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>An inadequately-explained phenomenon in computational complexity theory is that there are so few natural candidates for <a href="https://en.wikipedia.org/wiki/NP-intermediate">-intermediate problems</a>, problems in  but neither in  nor -complete. Of course, if  there are none, and the <a href="https://11011110.github.io/blog/2019/05/27/Schaefer's dichotomy theorem">dichotomy theorem</a> implies that there are no intermediate Boolean constraint satisfaction problems. But there are a lot of other types of problems in , and a theorem of Ladner<sup id="fnref:l"><a class="footnote" href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html#fn:l">1</a></sup> shows that there should be an infinite hierarchy of degrees of hardness within . So where are all the members of this hierarchy, and why are they so shy?</p>

<p>The same thing happens not just for  but for other related complexity classes like <a href="https://en.wikipedia.org/wiki/%E2%99%AFP"/>. There should be many -intermediate classes but we know even fewer than for . <a href="https://mathstodon.xyz/@11011110/102118180704402052">I recently posted</a> about a discussion I had with Igor Pak on this issue, in which we suggested to each other two number-theoretic candidates for being -intermediate, the <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler totient function</a> and the <a href="https://en.wikipedia.org/wiki/Prime-counting_function">prime-counting function</a> (see also <a href="https://cstheory.stackexchange.com/q/43954/95">Igor’s StackExchange question on this</a>). But although they’re in , neither of these functions is very combinatorial.</p>

<p>So anyway, the point of all this is to discuss more candidates for being -intermediate that are, I think, natural and combinatorial. They’re part of a family of problems that include a couple of related candidates for being -intermediate, and even a candidate for being -intermediate. These problems come from computational learning theory, or alternatively they can be seen as coming from mathematical logic, hereditary graph theory, and the theory of the <a href="https://en.wikipedia.org/wiki/Rado_graph">Rado graph</a>. And they’re all at what is in some sense the shallow end of the intermediate problems: they’re solvable in quasi-polynomial time, meaning , but not known to be solvable in polynomial time. So this is pretty strong evidence that they’re not complete for their respective complexity classes, but weaker evidence than usual that they’re not polynomial.</p>

<p>In learning theory, a family of sets  is said to <em>shatter</em> another set  (not necessarily belonging to ) if every subset of , including the empty set and  itself, can be obtained by intersecting  with some member of . The <a href="https://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_dimension">Vapnik–Chervonenkis dimension</a> of  is just the size of the largest set that is shattered by  . If we let  (the number of sets in the family) and  (the number of distinct elements in those sets), then the dimension is clearly at most , because sets of size larger than  have too many subsets for them all to be formed by intersection with a member of . Therefore, the following problem can be solved in quasipolynomial time, by a brute-force search of the  small-enough subsets of :<sup id="fnref:lmr"><a class="footnote" href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html#fn:lmr">2</a></sup></p>

<dl>
  <dt>VC-dimension (largest shattered set)</dt>
  <dd>Input: family of sets , number 

    <p>Output: true if  shatters a set of size , false otherwise.</p>
  </dd>
</dl>

<p>The same quasipolynomial time bound applies to the following related problems,
the first of which is also in  and the second of which is in :</p>

<dl>
  <dt>Smallest non-shattered set</dt>
  <dd>Input: family of sets , number 

    <p>Output: True if there exists a subset  of 
of size  that is not shattered by , false otherwise.</p>
  </dd>
  <dt>Number of shattered sets</dt>
  <dd>Input: family of sets 

    <p>Output: the number of sets shattered by .</p>
  </dd>
</dl>

<p>For the first two problems, being non--complete hinges on the assumption that , but for the number of shattered sets, being non--complete (under <a href="https://en.wikipedia.org/wiki/Polynomial-time_counting_reduction">counting reductions</a>) is unconditional: the output doesn’t provide enough bits of information to encode the answers to all other  problems.
The VC-dimension is hard to approximate under a form of the <a href="https://en.wikipedia.org/wiki/Exponential_time_hypothesis">exponential time hypothesis</a>, strongly suggesting that it cannot be computed exactly in polynomial time.<sup id="fnref:mr"><a class="footnote" href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html#fn:mr">3</a></sup></p>

<p>To see that the two existence problems can sometimes both have answers that are logarithmic, it’s helpful to turn to the theory of random graphs, and of <em>the</em> random graph, the <a href="https://en.wikipedia.org/wiki/Rado_graph">Rado graph</a>. This graph obeys a collection of <em>extension axioms</em> according to which, for every two disjoint finite subsets of vertices, there exists another vertex adjacent to everything in the first subset and to nothing in the second subset. Using these axioms, we can build up induced copies of any finite or countable subgraph, one vertex at a time, using a greedy algorithm. Based on this property, let’s define a subset  of the vertices in an undirected graph to be <em>extensible</em> if, for every partition of  into two disjoint subsets, there exists another vertex outside  that is adjacent to everything in the first subset and to nothing in the second subset. This is nothing more than being shattered by the neighborhoods of the vertices outside . So we have the following corresponding problems.</p>

<dl>
  <dt>Largest extensible set</dt>
  <dd>Input: Undirected graph , number 

    <p>Output: true if  has an extensible set of size , false otherwise.</p>
  </dd>
  <dt>Smallest non-extensible set</dt>
  <dd>Input: Undirected graph , number 

    <p>Output: true if  has a non-extensible set of size , false otherwise.</p>
  </dd>
  <dt>Smallest missing induced subgraph</dt>
  <dd>Input: Undirected graph , number 

    <p>Output: true if there is a graph  on at most  vertices that
is not an induced subgraph of , false otherwise.</p>
  </dd>
  <dt>Number of extensible sets</dt>
  <dd>Input: Undirected graph 

    <p>Output: The number of extensible sets of vertices of .</p>
  </dd>
</dl>

<p>The smallest missing induced subgraph size naturally falls into the complexity class  of problems for which you can guess a solution (the missing subgraph) but then verifying it involves solving a co- problem (is this subgraph missing).
It is greater than the size of the smallest non-extensible set, because if you try to build up a given induced subgraph by adding one vertex at a time greedily you can only get stuck at a non-extensible set. There must be a missing induced subgraph of size at most , because there are  isomorphism classes of -vertex labeled graphs and fewer than  ways of choosing which of the  labeled vertices correspond to vertices of , so for larger values of  than this bound there are more labeled graphs than placements of them as induced subgraphs. Another way of thinking about the smallest missing induced subgraph problem is that we are asking for the largest  for which  is <a href="https://en.wikipedia.org/wiki/Universal_graph">-universal</a>: it contains all graphs on at most  vertices as induced subgraphs.</p>

<p>The smallest non-extensible set and the smallest missing subgraph are both easy on any hereditary class of graphs, because these classes always have a missing subgraph of size . On the other hand, if  is chosen uniformly at random among the -vertex graphs, then any small subset of its vertices is extensible with high probability, so the smallest non-extensible set has expected size .</p>

<p>If these problems are not - and -complete, what are they? Papadimitriou and Yannakakis<sup id="fnref:py"><a class="footnote" href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html#fn:py">4</a></sup> define a complexity class , and show that VC-dimension is -complete. Presumably, because it’s so similar, the same is true for the largest extensible set. Maybe it’s possible to prove completeness for the smallest missing induced subgraph in an analogue of  at the level of , and to prove completeness for the number of shattered sets and number of extensible sets in an analogue of  at this level.</p>

<div class="footnotes">
  <ol>
    <li id="fn:l">
      <p>Ladner, Richard (1975), “<a href="https://doi.org/10.1145/321864.321877">On the structure of polynomial time reducibility</a>”, <em>J. ACM</em> 22 (1): 155–171. <a class="reversefootnote" href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html#fnref:l">↩</a></p>
    </li>
    <li id="fn:lmr">
      <p>Linial, Nathan, Mansour, Yishay, and Rivest, Ronald L. (1991), “<a href="https://doi.org/10.1016/0890-5401(91)90058-A">Results on learnability and the Vapnik–Chervonenkis dimension</a>”, <em>Inf. Comput.</em> 90 (1): 33–49. <a class="reversefootnote" href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html#fnref:lmr">↩</a></p>
    </li>
    <li id="fn:mr">
      <p>Manurangsi, Pasin, and Rubinstein, Aviad (2017), “<a href="http://proceedings.mlr.press/v65/manurangsi17a.html">Inapproximability of VC dimension and Littlestone’s dimension</a>”, <em>Proc. 2017 Conf. Learning Theory (COLT 2017)</em>, Proceedings of Machine Learning Research 65, pp. 1432–1460. <a class="reversefootnote" href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html#fnref:mr">↩</a></p>
    </li>
    <li id="fn:py">
      <p>Papadimitriou, Christos H., and Yannakakis, Mihalis (1996), “<a href="https://doi.org/10.1006/jcss.1996.0058">On limited nondeterminism and the complexity of the V–C dimension</a>”, <em>J. Comput. Syst. Sci.</em> 53 (2): 161–170. <a class="reversefootnote" href="https://11011110.github.io/blog/2019/05/27/shattering-quasipolynomiality.html#fnref:py">↩</a></p>
    </li>
  </ol>
</div>

<p>(<a href="https://mathstodon.xyz/@11011110/102170815471019923">Discuss on Mastodon</a>)</p></div>
    </content>
    <updated>2019-05-27T17:07:00Z</updated>
    <published>2019-05-27T17:07:00Z</published>
    <author>
      <name>David Eppstein</name>
    </author>
    <source>
      <id>https://11011110.github.io/blog/feed.xml</id>
      <author>
        <name>David Eppstein</name>
      </author>
      <link href="https://11011110.github.io/blog/feed.xml" rel="self" type="application/atom+xml"/>
      <link href="https://11011110.github.io/blog/" rel="alternate" type="text/html"/>
      <subtitle>Geometry, graphs, algorithms, and more</subtitle>
      <title>11011110</title>
      <updated>2019-05-28T06:05:39Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-3722233.post-3247584017741087776</id>
    <link href="https://blog.computationalcomplexity.org/feeds/3247584017741087776/comments/default" rel="replies" type="application/atom+xml"/>
    <link href="https://blog.computationalcomplexity.org/2019/05/separating-fact-from-fiction-with-56-of.html#comment-form" rel="replies" type="text/html"/>
    <link href="https://www.blogger.com/feeds/3722233/posts/default/3247584017741087776" rel="edit" type="application/atom+xml"/>
    <link href="https://www.blogger.com/feeds/3722233/posts/default/3247584017741087776" rel="self" type="application/atom+xml"/>
    <link href="https://blog.computationalcomplexity.org/2019/05/separating-fact-from-fiction-with-56-of.html" rel="alternate" type="text/html"/>
    <title>separating fact from fiction with the 56% of Americans say Arabic Numerals should not be taught in school</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><br/>
On the excellent TV show Veep there was a subplot about a political candidate (who himself had failed algebra in HS) objecting to Algebra since it was invented by the Muslims. I don't recall the exact line, but he said something like `Math teachers are terrorists'<br/>
This was, of course, fiction.<br/>
<br/>
The same week I read that 56% of survey respondents say `<u><i>Arabic Numerals' shouldn't be taught in</i></u> <i><u>schools'</u></i> Obviously also a fiction. Perhaps a headline from <i>The Onion</i>.<br/>
<br/>
No. The story is true.<br/>
<br/>
See snopes entry on this: <a href="https://www.snopes.com/fact-check/teaching-arabic-numerals/">here</a><br/>
<br/>
but also see many FALSE but FUNNY websites:<br/>
<br/>
Sarah Palin wants Arabic Numerals out of the schools: <a href="http://nationalreport.net/sarah-palin-wants-arabic-numerals-banned-americas-schools/">here</a> Funny but false.<br/>
<br/>
Jerry Brown is forcing students in California to learn Arabic Numerals as part of multi-culturism False by funny:  <a href="https://me.me/i/sharia-law-must-be-stopped-under-gov-brown-students-in-20990368">here</a><br/>
<br/>
A website urging us to use Roman Numerals (which Jesus used!) False but funny:  <a href="http://freedomnumerals.com/">here</a><br/>
<br/>
OKAY, what to make of the truth that really, really, 56% of Americans are against Arab Numerals<br/>
<br/>
1) Bigotry combined with ignorance.<br/>
<br/>
2) Some of the articles I read about this say its a problem with polls and people. There may be some of that, but still worries me.<br/>
<br/>
3) In Nazi Germany (WOW- Goodwin's law popped up rather early!) they stopped teaching relativity because Albert Einstein was Jewish (the story is more complicated than that, see <a href="https://www.scientificamerican.com/article/how-2-pro-nazi-nobelists-attacked-einstein-s-jewish-science-excerpt1/">her</a>e). That could of course never happen in America now (or could it, see <a href="https://www.tabletmag.com/jewish-news-and-politics/50097/time-warp">here</a> and <a href="https://www.conservapedia.com/index.php?title=Counterexamples_to_Relativity">here</a>).<br/>
<br/>
4) There is no danger that we will dump Arabic Numerals. I wonder if we will change there name to Freedom Numerals.<br/>
<br/>
5) Ignorance of science is a more immediate problem with the anti-vax people. See <a href="https://www.thedailybeast.com/measles-outbreak-grows-with-60-new-cases-across-26-states?ref=home">here</a><br/>
<br/>
<br/></div>
    </content>
    <updated>2019-05-27T15:12:00Z</updated>
    <published>2019-05-27T15:12:00Z</published>
    <author>
      <name>GASARCH</name>
      <email>noreply@blogger.com</email>
      <uri>http://www.blogger.com/profile/03615736448441925334</uri>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-3722233</id>
      <category term="typecast"/>
      <category term="focs metacomments"/>
      <author>
        <name>Lance Fortnow</name>
        <email>noreply@blogger.com</email>
        <uri>http://www.blogger.com/profile/06752030912874378610</uri>
      </author>
      <link href="https://blog.computationalcomplexity.org/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/>
      <link href="https://www.blogger.com/feeds/3722233/posts/default" rel="self" type="application/atom+xml"/>
      <link href="https://blog.computationalcomplexity.org/" rel="alternate" type="text/html"/>
      <link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/>
      <link href="https://www.blogger.com/feeds/3722233/posts/default?start-index=26&amp;max-results=25" rel="next" type="application/atom+xml"/>
      <subtitle>Computational Complexity and other fun stuff in math and computer science from Lance Fortnow and Bill Gasarch</subtitle>
      <title>Computational Complexity</title>
      <updated>2019-05-28T08:16:52Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10360</id>
    <link href="http://arxiv.org/abs/1905.10360" rel="alternate" type="text/html"/>
    <title>The advantages of multiple classes for reducing overfitting from test set reuse</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/f/Feldman:Vitaly.html">Vitaly Feldman</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/f/Frostig:Roy.html">Roy Frostig</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Hardt:Moritz.html">Moritz Hardt</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10360">PDF</a><br/><b>Abstract: </b>Excessive reuse of holdout data can lead to overfitting. However, there is
little concrete evidence of significant overfitting due to holdout reuse in
popular multiclass benchmarks today. Known results show that, in the
worst-case, revealing the accuracy of $k$ adaptively chosen classifiers on a
data set of size $n$ allows to create a classifier with bias of
$\Theta(\sqrt{k/n})$ for any binary prediction problem. We show a new upper
bound of $\tilde O(\max\{\sqrt{k\log(n)/(mn)},k/n\})$ on the worst-case bias
that any attack can achieve in a prediction problem with $m$ classes. Moreover,
we present an efficient attack that achieve a bias of $\Omega(\sqrt{k/(m^2
n)})$ and improves on previous work for the binary setting ($m=2$). We also
present an inefficient attack that achieves a bias of $\tilde\Omega(k/n)$.
Complementing our theoretical work, we give new practical attacks to
stress-test multiclass benchmarks by aiming to create as large a bias as
possible with a given number of queries. Our experiments show that the
additional uncertainty of prediction with a large number of classes indeed
mitigates the effect of our best attacks.
</p>
<p>Our work extends developments in understanding overfitting due to adaptive
data analysis to multiclass prediction problems. It also bears out the
surprising fact that multiclass prediction problems are significantly more
robust to overfitting when reusing a test (or holdout) dataset. This offers an
explanation as to why popular multiclass prediction benchmarks, such as
ImageNet, may enjoy a longer lifespan than what intuition from literature on
binary classification suggests.
</p></div>
    </summary>
    <updated>2019-05-27T23:30:41Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10337</id>
    <link href="http://arxiv.org/abs/1905.10337" rel="alternate" type="text/html"/>
    <title>What Can ResNet Learn Efficiently, Going Beyond Kernels?</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/a/Allen=Zhu:Zeyuan.html">Zeyuan Allen-Zhu</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Li:Yuanzhi.html">Yuanzhi Li</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10337">PDF</a><br/><b>Abstract: </b>How can neural networks such as ResNet $\textit{efficiently}$ learn CIFAR-10
with test accuracy more than 96%, while other methods, especially kernel
methods, fall far behind? Can we more provide theoretical justifications for
this gap?
</p>
<p>There is an influential line of work relating neural networks to kernels in
the over-parameterized regime, proving that they can learn certain concept
class that is also learnable by kernels, with similar test error. Yet, can we
show neural networks provably learn some concept class $\textit{better}$ than
kernels?
</p>
<p>We answer this positively in the PAC learning language. We prove neural
networks can efficiently learn a notable class of functions, including those
defined by three-layer residual networks with smooth activations, without any
distributional assumption. At the same time, we prove there are simple
functions in this class that the test error obtained by neural networks can be
$\textit{much smaller}$ than $\textit{any}$ "generic" kernel method, including
neural tangent kernels, conjugate kernels, etc.
</p>
<p>The main intuition is that $\textit{multi-layer}$ neural networks can
implicitly perform hierarchal learning using different layers, which reduces
the sample complexity comparing to "one-shot" learning algorithms such as
kernel methods.
</p></div>
    </summary>
    <updated>2019-05-27T23:29:59Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10284</id>
    <link href="http://arxiv.org/abs/1905.10284" rel="alternate" type="text/html"/>
    <title>Hardness of Distributed Optimization</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Nir Bachrach, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/c/Censor=Hillel:Keren.html">Keren Censor-Hillel</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/d/Dory:Michal.html">Michal Dory</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/e/Efron:Yuval.html">Yuval Efron</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Leitersdorf:Dean.html">Dean Leitersdorf</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Paz:Ami.html">Ami Paz</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10284">PDF</a><br/><b>Abstract: </b>This paper studies lower bounds for fundamental optimization problems in the
CONGEST model. We show that solving problems exactly in this model can be a
hard task, by providing $\tilde{\Omega}(n^2)$ lower bounds for cornerstone
problems, such as minimum dominating set (MDS), Hamiltonian path, Steiner tree
and max-cut. These are almost tight, since all of these problems can be solved
optimally in $O(n^2)$ rounds. Moreover, we show that even in bounded-degree
graphs and even in simple graphs with maximum degree 5 and logarithmic
diameter, it holds that various tasks, such as finding a maximum independent
set (MaxIS) or a minimum vertex cover, are still difficult, requiring a
near-tight number of $\tilde{\Omega}(n)$ rounds.
</p>
<p>Furthermore, we show that in some cases even approximations are difficult, by
providing an $\tilde{\Omega}(n^2)$ lower bound for a
$(7/8+\epsilon)$-approximation for MaxIS, and a nearly-linear lower bound for
an $O(\log{n})$-approximation for the $k$-MDS problem for any constant $k \geq
2$, as well as for several variants of the Steiner tree problem.
</p>
<p>Our lower bounds are based on a rich variety of constructions that leverage
novel observations, and reductions among problems that are specialized for the
CONGEST model. However, for several additional approximation problems, as well
as for exact computation of some central problems in $P$, such as maximum
matching and max flow, we show that such constructions cannot be designed, by
which we exemplify some limitations of this framework.
</p></div>
    </summary>
    <updated>2019-05-27T23:31:34Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10143</id>
    <link href="http://arxiv.org/abs/1905.10143" rel="alternate" type="text/html"/>
    <title>A Practical Framework for Solving Center-Based Clustering with Outliers</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/d/Ding:Hu.html">Hu Ding</a>, Haikuo Yu <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10143">PDF</a><br/><b>Abstract: </b>Clustering has many important applications in computer science, but
real-world datasets often contain outliers. Moreover, the existence of outliers
can make the clustering problems to be much more challenging. In this paper, we
propose a practical framework for solving the problems of
$k$-center/median/means clustering with outliers. The framework actually is
very simple, where we just need to take a small sample from input and run
existing approximation algorithm on the sample. However, our analysis is
fundamentally different from the previous sampling based ideas. In particular,
the size of the sample is independent of the input data size and
dimensionality. To explain the effectiveness of random sampling in theory, we
introduce a "significance" criterion and prove that the performance of our
framework depends on the significance degree of the given instance. Actually,
our result can be viewed as a new step along the direction of beyond worst-case
analysis in terms of clustering with outliers. The experiments suggest that our
framework can achieve comparable clustering result with existing methods, but
greatly reduce the running time.
</p></div>
    </summary>
    <updated>2019-05-27T23:32:18Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.10017</id>
    <link href="http://arxiv.org/abs/1905.10017" rel="alternate" type="text/html"/>
    <title>Computational cost for determining an approximate global minimum using the selection and crossover algorithm</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/i/Isomura:Takuya.html">Takuya Isomura</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.10017">PDF</a><br/><b>Abstract: </b>This work examines the expected computational cost to determine an
approximate global minimum of a class of cost functions characterized by the
variance of coefficients. The cost function takes $N$-dimensional binary states
as arguments and has many local minima. Iterations in the order of $2^N$ are
required to determine an approximate global minimum using random search. This
work analytically and numerically demonstrates that the selection and crossover
algorithm with random initialization can reduce the required computational cost
(i.e., number of iterations) for identifying an approximate global minimum to
the order of $\lambda^N$ with $\lambda$ less than 2. The two best solutions,
referred to as parents, are selected from a pool of randomly sampled states.
Offspring generated by crossovers of the parents' states are distributed with a
mean cost lower than that of the original distribution that generated the
parents. It is revealed that in contrast to the mean, the variance of the cost
of the offspring is asymptotically the same as that of the original
distribution. Consequently, sampling from the offspring's distribution leads to
a higher chance of determining an approximate global minimum than sampling from
the original distribution, thereby accelerating the global search. This feature
is distinct from the distribution obtained by a mixture of a large population
of favorable states, which leads to a lower variance of offspring. These
findings demonstrate the advantage of the crossover between two favorable
states over a mixture of many favorable states for an efficient determination
of an approximate global minimum.
</p></div>
    </summary>
    <updated>2019-05-27T23:21:38Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.09992</id>
    <link href="http://arxiv.org/abs/1905.09992" rel="alternate" type="text/html"/>
    <title>Fast Convergence of Belief Propagation to Global Optima: Beyond Correlation Decay</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Koehler:Frederic.html">Frederic Koehler</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.09992">PDF</a><br/><b>Abstract: </b>Belief propagation is a fundamental message-passing algorithm for
probabilistic reasoning and inference in graphical models. While it is known to
be exact on trees, in most applications belief propagation is run on graphs
with cycles. Understanding the behavior of "loopy" belief propagation has been
a major challenge for researchers in machine learning, and positive convergence
results for BP are known under strong assumptions which imply the underlying
graphical model exhibits decay of correlations. We show that under a natural
initialization, BP converges quickly to the global optimum of the Bethe free
energy for Ising models on arbitrary graphs, as long as the Ising model is
\emph{ferromagnetic} (i.e. neighbors prefer to be aligned). This holds even
though such models can exhibit long range correlations and may have multiple
suboptimal BP fixed points. We also show an analogous result for iterating the
(naive) mean-field equations; perhaps surprisingly, both results are
dimension-free in the sense that a constant number of iterations already
provides a good estimate to the Bethe/mean-field free energy.
</p></div>
    </summary>
    <updated>2019-05-27T23:36:34Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.09952</id>
    <link href="http://arxiv.org/abs/1905.09952" rel="alternate" type="text/html"/>
    <title>Accelerated Primal-Dual Coordinate Descent for Computational Optimal Transport</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Guo:Wenshuo.html">Wenshuo Guo</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Ho:Nhat.html">Nhat Ho</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/j/Jordan:Michael_I=.html">Michael I. Jordan</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.09952">PDF</a><br/><b>Abstract: </b>We propose and analyze a novel accelerated primal-dual coordinate descent
framework for computing the optimal transport (OT) distance between two
discrete probability distributions. First, we introduce the accelerated
primal-dual randomized coordinate descent (APDRCD) algorithm for computing OT.
Then we provide a complexity upper bound
$\widetilde{\mathcal{O}}(\frac{n^{5/2}}{\varepsilon})$ for the APDRCD method
for approximating OT distance, where $n$ stands for the number of atoms of
these probability measures and $\varepsilon &gt; 0$ is the desired accuracy. This
upper bound matches the best known complexities of adaptive primal-dual
accelerated gradient descent (APDAGD) and adaptive primal-dual accelerate
mirror descent (APDAMD) algorithms while it is better than those of Sinkhorn
and Greenkhorn algorithms, which are of the order
$\widetilde{\mathcal{O}}(\frac{n^{2}}{\varepsilon^2})$, in terms of the desired
accuracy $\varepsilon &gt; 0$. Furthermore, we propose a greedy version of APDRCD
algorithm that we refer to as the accelerated primal-dual greedy coordinate
descent (APDGCD) algorithm and demonstrate that it has a better practical
performance than the APDRCD algorithm. Extensive experimental studies
demonstrate the favorable performance of the APDRCD and APDGCD algorithms over
state-of-the-art primal-dual algorithms for OT in the literature.
</p></div>
    </summary>
    <updated>2019-05-27T23:21:46Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1905.09898</id>
    <link href="http://arxiv.org/abs/1905.09898" rel="alternate" type="text/html"/>
    <title>Graph regret bounds for Thompson Sampling and UCB</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lykouris:Thodoris.html">Thodoris Lykouris</a>, Eva Tardos, Drishti Wali <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1905.09898">PDF</a><br/><b>Abstract: </b>We study the stochastic multi-armed bandit problem with the graph-based
feedback structure introduced by Mannor and Shamir. We analyze the performance
of the two most prominent stochastic bandit algorithms, Thompson Sampling and
Upper Confidence Bound (UCB), in the graph-based feedback setting. We show that
these algorithms achieve regret guarantees that combine the graph structure and
the gaps between the means of the arm distributions. Surprisingly this holds
despite the fact that these algorithms do not explicitly use the graph
structure to select arms. Towards this result we introduce a "layering
technique" highlighting the commonalities in the two algorithms.
</p></div>
    </summary>
    <updated>2019-05-27T23:32:28Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/1808.01949</id>
    <link href="http://arxiv.org/abs/1808.01949" rel="alternate" type="text/html"/>
    <title>OptStream: Releasing Time Series Privately</title>
    <feedworld_mtime>1558915200</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/f/Fioretto:Ferdinando.html">Ferdinando Fioretto</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Hentenryck:Pascal_Van.html">Pascal Van Hentenryck</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/1808.01949">PDF</a><br/><b>Abstract: </b>Many applications of machine learning and optimization operate on data
streams. While these datasets are fundamental to fuel decision-making
algorithms, often they contain sensitive information about individuals and
their usage poses significant privacy risks. Motivated by an application in
energy systems, this paper presents OPTSTREAM, a novel algorithm for releasing
differentially private data streams under the w-event model of privacy.
OPTSTREAM is a 4-step procedure consisting of sampling, perturbation,
reconstruction, and post-processing modules. First, the sampling module selects
a small set of points to access in each period of interest. Then, the
perturbation module adds noise to the sampled data points to guarantee privacy.
Next, the reconstruction module reassembles non-sampled data points from the
perturbed sample points. Finally, the post-processing module uses convex
optimization over the private output of the previous modules, as well as the
private answers of additional queries on the data stream, to improve accuracy
by redistributing the added noise. OPTSTREAM is evaluated on a test case
involving the release of a real data stream from the largest European
transmission operator. Experimental results show that OPTSTREAM may not only
improve the accuracy of state-of-the-art methods by at least one order of
magnitude but also supports accurate load forecasting on the private data.
</p></div>
    </summary>
    <updated>2019-05-27T23:32:39Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2019-05-27T01:30:00Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-27705661.post-955320605612447790</id>
    <link href="http://processalgebra.blogspot.com/feeds/955320605612447790/comments/default" rel="replies" type="application/atom+xml"/>
    <link href="http://www.blogger.com/comment.g?blogID=27705661&amp;postID=955320605612447790" rel="replies" type="text/html"/>
    <link href="http://www.blogger.com/feeds/27705661/posts/default/955320605612447790" rel="edit" type="application/atom+xml"/>
    <link href="http://www.blogger.com/feeds/27705661/posts/default/955320605612447790" rel="self" type="application/atom+xml"/>
    <link href="http://processalgebra.blogspot.com/2019/05/an-interview-with-jamie-gabbay-and.html" rel="alternate" type="text/html"/>
    <title>An interview with Jamie Gabbay and Andrew Pitts, 2019 Alonzo Church Award recipients</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">The 2019 Alonzo Church Award committee consisting of Thomas Eiter, Javier Esparza, Radha Jagadeesan, Catuscia Palamidessi, and Natarajan Shankar, have selected <a href="http://www.gabbay.org.uk/">Murdoch J. Gabbay </a>and <a href="https://www.cl.cam.ac.uk/~amp12/">Andrew M. Pitts </a>for the <a href="http://eatcs.org/index.php/component/content/article/1-news/2812-the-2019-alonzo-church-award">2019 Alonzo Church Award</a>, for introducing the theory of nominal representations, a powerful and elegant mathematical model for computing with data involving atomic names. In particular, the nomination for the Alonzo Church Award singled out the following two papers:<br/><ul><li>“<a href="https://www.cl.cam.ac.uk/~amp12/papers/newaas/newaas-jv.pdf">A new approach to abstract syntax with variable binding</a>” by Murdoch J. Gabbay and Andrew M. Pitts, Formal Aspects of Computing 13(3):341– 363, 2002; and</li><li>“<a href="https://www.cl.cam.ac.uk/~amp12/papers/nomlfo/nomlfo-draft.pdf">Nominal logic, a first order theory of names and binding</a>” by Andrew M. Pitts, Information and Computation 186(2):165–193, 2003.</li></ul>For the conference version of the first article, Andy and Jamie will also be receiving the Test-of-Time Award from LICS 1999.<br/><br/>The award recipients kindly agreed to answer some questions of mine via email. You can find the transcript of the interview below. My questions are labelled with <b>LA</b>, Andy's answers with <b>AP</b> and Jamie's with <b>JG</b>. I hope that you'll enjoy reading their insights and the story of their award-receiving work as much as I did myself. <br/><br/><div dir="ltr"><b>LA: </b>You are receiving the 2019 Alonzo Church Award  for  Outstanding Contributions to Logic and Computation as well as the  Test-of-Time Award from LICS 1999 for your invention of nominal  techniques to provide a semantic understanding of abstract syntax with  binding.   Could you briefly describe the history of the ideas that led  you to use the <a href="https://en.wikipedia.org/wiki/Permutation_model">permutation model of set theory with atoms</a> due to  Fraenkel and Mostowski to represent name abstraction and fresh name  generation? What were the  main inspirations and motivations for your work? In your opinion, how  did nominal techniques advance the state of the art at that time?</div><div dir="ltr"/><br/><div dir="ltr"><b>AP: </b>I have had a long-standing interest in the mathematical semantics of programming language features that restrict resources to a specific scope, or hide information from a program's environment; think local mutable state in languages like <a href="http://ocaml.org/">OCaml</a>, or channel-name restriction in the <a href="https://en.wikipedia.org/wiki/%CE%A0-calculus">pi-calculus</a>. When <a href="http://homepages.inf.ed.ac.uk/stark/">Ian Stark</a> was doing his PhD with me in the 90s we tried to understand a simple instance: the observable properties of higher-order functions combined with dynamically generated atomic names that can be tested for equality, but don't have any other attribute -- we called this the "nu-calculus". Ian gave a denotational semantics for the nu-calculus using Moggi's monad for modelling dynamic allocation. That monad is defined on the category of pullback-preserving functors from the category of injective functions between finite ordinals to the category of sets. This functor category was well-known to me from topos theory, where it is called <a href="https://ncatlab.org/nlab/show/Schanuel+topos">Schanuel's topos </a>and hosts the generic model of a geometric theory of an infinite decidable set.  A few years later, when Jamie joined me as a PhD student in 1998, I suggested we look at the Schanuel topos as a setting for initial algebra semantics of syntax involving binding operations, modulo alpha-equivalence. I think Jamie prefers set theory over category theory, so he pushed us to use another known equivalent presentation of the Schanuel topos, in terms of continuous actions of the group of permutations of the set N of natural numbers (topologized as a subspace of the product of countably many copies of N). In this form there is an obvious connection with the cumulative hierarchy of sets (with atoms) that are hereditarily finitely supported with respect to the action of permuting atoms. This universe of sets was devised by Fraenkel and Mostowski in the first part of the twentieth century to model ZFA set theory without axioms of choice.  Whether one emphasises set theory or category theory, the move to making permutations of names, rather than injections between sets of names, the primary concept was very fruitful. For example, it certainly makes higher-order constructions (functions and powersets) in the topos/set-theory easier to describe and use. We ended up with a generic construction for name-abstraction modulo <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence">alpha-equivalence</a> compatible with classical higher-order logic or set theory, so long as one abstains from unrestricted use of choice. </div><div dir="ltr"/><div dir="ltr"><br/><b>JG:</b> At the time it wasn't an idea to consider names as elements of a distinctive datatype of names, with properties just like other datatypes such as the natural numbers Nat. If we want to add 1 to 1, we take 1:Nat and invoke the "plus" function, which is a specific thing associated to Nat; so why not abstract a in x by assuming a:Atm (where Atm is a distinct thing in our mathematical universe) and x:X and invoking a function "abstract", which is a thing associated to Atm?  We unfolded the implications of this idea in set theory and rediscovered FM sets.  I was inspired by the way I saw mathematics built up in ZF set theory as an undergraduate, starting from a simple basis and building up the cumulative hierarchy.  When I saw the chance to do this for a universe with names, I jumped at the chance.  It turns out FM sets are not required.  Nominal techniques can be built in ZFA set theory, which contains more functions and permits unrestricted choice. </div><div dir="ltr"><br/><b>LA: </b>Over  the last fifteen years, nominal techniques have become a fundamental  tool for modelling locality in computation, underlying research  presented in over a hundred papers, new programming languages and models  of computation. They have applications to the syntax and semantics of  programming languages, to logics for machine-assisted reasoning about  programming-language semantics and to the automatic verification of  specifications in process calculi. Variations on nominal sets are used  in automata theory over infinite alphabets, with applications to  querying XML and databases, and also feature in work on models of  Homotopy Type Theory. When did it dawn on you that you had succeeded in  finding a very good model for name abstraction and fresh name  generation, and one that would have a  lot of impact? Did you imagine that your model would generate such a  large amount of follow-up work, leading to a whole body of work on  nominal computation theory? <br/><br/><b>AP: </b>No, to begin with I was very focussed on getting better techniques for computing and reasoning about syntax with bound names. But that only represents a part of the current broad landscape of nominal techniques, the part that mainly depends on the mathematical notion of "finite support" (a way of expressing, via name-permutation, that an object only involves finitely many names). Independently of us, some people realised that a related notion of finiteness, "orbit-finiteness" (which expresses that an object is finite modulo symmetries) is crucial for many applications of nominal techniques. I am referring to the work of Montanari and Pistore on pi-calculus and <a href="https://core.ac.uk/download/pdf/82414059.pdf">HD automata </a>using named sets (yet another equivalent of the Schanuel topos) and the work on automata theory over infinite alphabets (and much else besides) using "sets with atoms" by the Warsaw group (Bojanczyk, Klin, Lasota, Torunczyk,...). The latter is particularly significant because it considers groups of symmetry for atoms other than the full permutation group (in which the only property of an atom preserved under symmetry is its identity). <br/><br/><b>JG:</b> Yes, I did.  Nobody could anticipate the specific applications but I knew we were on to something, which is why I stayed on to build the field after the PhD.  The amount of structure was just too striking.  This showed early: e.g. in the equivariance properties, and the commutation of nominal atoms-abstraction with function-spaces.  When I sent the proof of this property to Andrew, at first he didn't believe it!  I had a sense that there was something deep going on and I still do. <br/><br/><b>LA: </b>What is the result of  yours on nominal techniques you are most proud of? And what are your  favourite results amongst those achieved by others on nominal computation?<b/><br/><b><br/></b><b>AP:</b> Not so much a specific result, but rather a logical concept, the freshness quantifier (which we wrote using an upside down "N" -- N stands for "New"). In informal practice when reasoning about syntax involving binders, one often chooses <i>some</i> fresh name for the bound variable, but then has to revise that choice in view of later ones; but fortunately <i>any </i>fresh name does as well as some particular one. This distinctive "some/any" property occurs all over the place when computing and reasoning about languages with binders and the freshness quantifier formalises it, in terms of the freshness ("not in the support of") relation and conventional quantifiers.  For the second part of your question I would choose two things. One is the work by Jamie with Fernandez and Mackie on <a href="https://www.sciencedirect.com/science/article/pii/S0890540106001635">nominalrewriting systems</a>, which won the PPDP Most Influential Paper 10-year Award in 2014. The second is the characterisation of orbit-finite sets with atoms in terms of "set-builder expressions"---see Klin et al, "<a href="https://www.mimuw.edu.pl/~szymtor/papers/locfin.pdf">Locally Finite Constraint Satisfaction Problems</a>", Proc. LICS 2015); it's a nice application of the classical model theory of homogeneous structures with interesting applications for languages that compute with finite structures. <br/><br/><b>JG:</b> Thanks for asking.  Aside from the initial papers, my work on nominal rewriting with Fernandez has probably had most impact.  However, I am rather fond of the thread of research going from Nominal Algebra, through the axiomatisation of substitution and first-order logic and the characterisation of quantification as a limit in nominal sets, and on to Stone duality.  It's a mathematical foundation built from a nominal perspective of naming and quantification and I hope that as the state of the art in nominal techniques advances and broadens, it might prove useful.  Andrew's book has been helpful in marking out nominal techniques as a field.  I also agree with Andrew that orbit-finiteness and the applications of this idea to transition systems and automata, is important.  I like the automata work for another concrete reason: nominal techniques were discovered in the context of names and binding in syntax, which has bequeathed a misconception that nominal techniques are <i>only</i> about this.  The Warsaw school of nominal techniques gives an independent illustration of the other applications of these ideas. <br/><b><br/></b><b><b>LA: </b></b>Twenty years have passed since your LICS 1999 paper and the  literature on variations on nominal techniques now contains over a hundred papers. Do you expect any further  development related to the theory and application of nominal techniques in the  coming years? What advice would you give to a PhD student who is  interested in working on topics related to nominal computation today?</div><div dir="ltr"><br/><b>AP: </b> For the purpose of answering your question, let's agree to divide LICS topics into Programming Languages and Semantics (PLS) versus Logic and Algorithms (LAS). (So long as we don't think of it as a dichotomy!) Then it seems to me that applications of nominal techniques to LAS are currently in the ascendant and show no sign of slowing down. My own interests are with PLS and there is still work to be done there. In particular, I would like better support for using nominal techniques within the mainstream interactive theorem proving systems: we have the Nominal Package of Urban and Berghofer for classical higher-order logic within Isabelle (which lead to Urban and Tasson winning the CADE Skolem Award in 2015), but nothing analogous for systems based on dependent type theory, such as Agda, Coq and Lean. Recent work of Swan (arXiv:1702.01556) gives us a better understanding of how to develop nominal sets within constructive logic; but I have yet to see a dependent type theory that both corresponds to some form of constructive nominal logic under Curry-Howard and is sufficiently simple that it appeals to users of systems lke Coq who want to mechanise programming language meta-theory in a nameful style. Really, I would like the utility of the FreshML programming language that Jamie, Mark Shinwell and I proposed in 2003 (and which Mark implemented as a patch of OCaml) restricted to total functional programming in the style of Agda; but I don't quite know how to achieve that. <br/><br/><b>JG:</b> Yes.  We are far from understanding nominal techniques and the field has a lot of life and will continue to surprise.  I've always believed that.  A key sticking-point right now is implementations.  I wrote a paper about this recently, on equivariance and the foundations of nominal techniques.  One point in the paper is a sketch for a next-generation nominal theorem-prover (based on ZFA + equivariance).  I'd like to see this carried out, so if anybody reading this is interested then please be in touch.  I'd also like to see nominal techniques implemented as a package in a language like Haskell, ML, or even Python!  If we can get this stuff into the working programmer's toolbox, in a way that just works and does not require special configuration, then that would be helpful.  I suspect that nominal techniques as currently presented in the maths papers, might not fit into a programming language at the moment.  The theory is too strong and may need weakened first.  We need a subset of nominal techniques weak enough to squeeze into an existing language, yet expressive enough for interesting applications.  Some general advice, specifically for the PhD student.  If you have an idea which most people around you don't understand, consider this may be a gap in the collective imagination.  There can be peer pressure when faced by incomprehension to blame yourself, back down, and think about something else.  By all means do this, but only if you yourself judge it right to do so. <br/><br/></div><b>LA: </b>Is there any general research-related lesson you have learnt in the process of working on nominal techniques?<br/><br/><b>AP: </b>On the one hand, don't lose sight of what application your theory is supposed to be good for; but on the other hand, let beauty and simplicity be your guide.<br/><br/><b>JG:</b> Yes:<br/><ul><li>Proving stuff is 30% of the work; convincing people is 70%. </li><li>It's the basic ideas that are hard, not the complicated theorems.</li><li>Competence and imagination are orthogonal. </li><li>It's doesn't have to be complex to be clever. </li><li>Elegant + applicable is a potent combination. </li><li>Seek out good listeners.  Give up quickly on bad ones.  Try to be a good listener. </li><li>Other people have a lot to teach you, but it might not be the things you expected. </li><li>Writing papers is fun.   </li></ul><b>LA: </b>Thanks to both of you for your willingness to answer my questions and congratulations for the awards you will be receiving this summer!</div>
    </content>
    <updated>2019-05-26T22:52:00Z</updated>
    <published>2019-05-26T22:52:00Z</published>
    <author>
      <name>Luca Aceto</name>
      <email>noreply@blogger.com</email>
      <uri>http://www.blogger.com/profile/01092671728833265127</uri>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-27705661</id>
      <author>
        <name>Luca Aceto</name>
        <email>noreply@blogger.com</email>
        <uri>http://www.blogger.com/profile/01092671728833265127</uri>
      </author>
      <link href="http://processalgebra.blogspot.com/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/>
      <link href="http://www.blogger.com/feeds/27705661/posts/default" rel="self" type="application/atom+xml"/>
      <link href="http://processalgebra.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/>
      <link href="http://www.blogger.com/feeds/27705661/posts/default?start-index=26&amp;max-results=25" rel="next" type="application/atom+xml"/>
      <subtitle>Papers I find interesting---mostly, but not solely, in Process Algebra---, and some fun stuff in Mathematics and Computer Science at large and on general issues related to research, teaching and academic life.</subtitle>
      <title>Process Algebra Diary</title>
      <updated>2019-05-27T08:25:45Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>https://eccc.weizmann.ac.il/report/2019/076</id>
    <link href="https://eccc.weizmann.ac.il/report/2019/076" rel="alternate" type="text/html"/>
    <title>TR19-076 |  The Equivalences of Refutational QRAT | 

	Leroy Chew, 

	Judith Clymo</title>
    <summary>The solving of Quantified Boolean Formulas (QBF) has been advanced considerably in the last two decades. In response to this, several proof systems have been put forward to universally verify QBF solvers. 
QRAT by Heule et al. is one such example of this and builds on technology from DRAT, a checking format used in propositional logic. 
Recent advances have shown conditional optimality results for QBF systems that use extension variables.
Since QRAT can simulate Extended Q-Resolution, we know it is strong, but we do not know if QRAT has the strategy extraction property as Extended Q-Resolution does. In this paper, we partially answer this question by showing that QRAT with a restricted reduction rule has strategy extraction (and consequentially is equivalent to Extended Q-Resolution modulo NP).
We also extend equivalence to another system, as we show an augmented version of QRAT known as QRAT+, developed by Lonsing and Egly, is in fact equivalent to the basic QRAT. We achieve this by constructing a line-wise simulation of QRAT+ using only steps valid in QRAT.</summary>
    <updated>2019-05-26T10:13:58Z</updated>
    <published>2019-05-26T10:13:58Z</published>
    <source>
      <id>https://eccc.weizmann.ac.il/</id>
      <author>
        <name>ECCC papers</name>
      </author>
      <link href="https://eccc.weizmann.ac.il/" rel="alternate" type="text/html"/>
      <link href="https://example.com/feeds/reports/" rel="self" type="application/atom+xml"/>
      <subtitle>Latest Reports published at https://eccc.weizmann.ac.il</subtitle>
      <title>ECCC - Reports</title>
      <updated>2019-05-28T19:21:02Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://11011110.github.io/blog/2019/05/25/more-matching-mimicking</id>
    <link href="https://11011110.github.io/blog/2019/05/25/more-matching-mimicking.html" rel="alternate" type="text/html"/>
    <title>More matching-mimicking networks</title>
    <summary>My paper with Vijay Vazirani on parallel matching (soon to appear in SPAA) is based on the idea of a “matching-mimicking network”. If is a graph with a designated set of terminal vertices, then a matching-mimicking network for is another graph with the same terminals that has the same pattern of matchings. Here, by a pattern of matchings, I mean a family of subsets of , the subsets that can be covered by a matching that also covers all non-terminal vertices. We included a messy case analysis that, after some simplifications due to symmetry, had 21 cases for the matching mimicking networks on at most three terminals.</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>My <a href="https://11011110.github.io/blog/2018/02/01/parallel-matching-in.html">paper with Vijay Vazirani on parallel matching</a> (soon to appear in <a href="http://spaa.acm.org/2019/">SPAA</a>) is based on the idea of a “matching-mimicking network”. If  is a graph with a designated set  of terminal vertices, then a matching-mimicking network for  is another graph  with the same terminals that has the same pattern of matchings. Here, by a <em>pattern of matchings</em>, I mean a family of subsets of , the subsets that can be covered by a matching that also covers all non-terminal vertices. We included a messy case analysis that, after some simplifications due to symmetry, had 21 cases for the matching mimicking networks on at most three terminals.</p>

<p>By now, I think I understand patterns of matchings a lot better, enough to do the three-terminal case in only four cases and to extend the analysis to four terminals in only seven more cases. The starting point is the observation that these patterns of matchings are <a href="https://en.wikipedia.org/wiki/Delta-matroid">even Δ-matroids</a>.</p>

<p>One way to think of a Δ-matroid is that it’s just a convex polyhedron or polytope in Euclidean space of some dimension , with the properties that all vertex coordinates are  or  and all edge lengths are  or . An even Δ-matroid has the stronger property that all edge lengths are , as is true for the three-dimensional regular tetrahedron with vertex coordinates (written in a more compact form as bitvectors) , , , and .</p>

<p style="text-align: center;"><img alt="Regular tetrahedron formed from alternating vertices of a cube" src="https://11011110.github.io/blog/assets/2019/tet-in-cube.svg"/></p>

<p>Alternatively one can consider the same kind of structure to be a family of sets, drawn from a universe of  elements that correspond to the dimensions of the space. Each set in the family corresponds to a vertex of the polytope and includes the elements whose coordinates are one. So over the three-element set  the same regular tetrahedron can be written as the family of sets</p>



<p>When expressed in this way, the sets of a Δ-matroid obey an exchange axiom: if two sets  and  differ on whether they include some element , then there must exist an element  on which they also differ, so that the symmetric difference of sets  also belongs to the Δ-matroid. By repeatedly applying this axiom one can connect  to  by a geodesic path (in Hamming distance) of two-element moves. For the bases of a matroid, we have a stronger requirement that one of the two elements belongs to  and the other belongs to , or equivalently that all sets have the same size, but a Δ-matroid relaxes this requirement. It’s not even required that ! But in an even Δ-matroid  and  must be distinct, because otherwise the step would be along an edge of length one. Another way of expressing the extra requirements of an even Δ-matroid over an arbitrary Δ-matroid is that all sets must have the same parity (all have even size, or all have odd size).</p>

<p>So anyway, back to matching. Suppose that both  and  are sets drawn from a pattern of matchings. Choose arbitrarily a matching representing each set. Then the symmetric difference of these matchings is a collection of disjoint alternating paths and cycles, and we can get from  to  by 
a sequence of steps in which we take the symmetric difference of the current matching by one of the alternating paths. So this gives us not just one geodesic from  to  but a lot of different geodesics, one for each ordering of the alternating paths. Expressed as an exchange axiom, this means that when two sets  and  differ, the elements on which they differ can be partitioned into pairs, the symmetric differences with which can be performed independently. You can pick any subset of the pairs of differing elements, and change each of those pairs, leaving the rest alone. Because this is a strengthening of the even Δ-matroid axiom, every matching pattern is an even Δ-matroid.</p>

<p>Expressed in polyhedral terms, this stronger exchange axiom means that every two vertices at distance  from each other are connected by a -dimensional hypercube with side length . This is a little weird, because we started with a hypercube but then eliminated half of its vertices (by the parity condition) to get something else. Now we have hypercubes again, of lower dimension. They must be tilted with respect to the coordinate axes: each axis of one of these lower-dimensional hypercubes is tilted at a 45 degree angle with respect to the coordinate system of the overall polytope.</p>

<p>Not every even Δ-matroid obeys this sub-hypercube property. On the other hand, I was expecting the matching patterns that are matroids (all sets are the same size) to be transversal matroids (maximal subsets of vertices on one side of a bipartite graph that can be covered by a matching), and they aren’t. There is a six-element non-transversal matroid, whose six elements are the edges of a triangle with doubled edges and whose sets are pairs of edges from different sides of the triangle. But it is the pattern of matchings of a tree in which the (non-terminal) root has three children, each of which has two terminals as its children.</p>

<p>Conveniently, whether a 0-1 polyhedron can be represented by a pattern of matchings depends only on its shape and not on its orientation. You can obviously permute the coordinates of a polyhedron that represents a pattern of matchings, by relabeling which coordinate corresponds to which terminal vertex. But you can also reflect the polyhedron across any one of its coordinates by modifying the graph whose matchings represent it in the following way: turn the  terminal vertex for that coordinate into a non-terminal, and attach a new degree-one terminal vertex to it. These permutations and reflections generate all the symmetries of the hypercube in which the 0-1 polyhedron lives. So to find small matching-mimicking networks, we only need to look at one representative 0-1 polyhedron in each symmetry class. If we find a small network for this representative, we can modify it to create a different small matching-mimicking network for every other 0-1 polyhedron with the same shape.</p>

<p>So what are the possible shapes? Let’s define the dimension of a Δ-matroid to be the number of coordinates of the polytope that take both values,  and , at different vertices. Then a 0-dimensional even Δ-matroid must be a single point (), there are no 1-dimensional even Δ-matroids, and a two-dimensional even Δ-matroid must be a line segment (). There are two three-dimensional even Δ-matroids: a triangle  and the tetrahedron shown above, . The cube exchange axiom for patterns of matching starts to kick in for four-dimensional even Δ-matroids, whose vertices must be subsets of the four-dimensional hyperoctahedron . (This is the shape formed from a four-dimensional hypercube by keeping only vertices with the same parity as each other, just as we formed a regular tetrahedron by doing the same thing to a three-dimensional cube.) Here’s a drawing of  from <a href="https://11011110.github.io/blog/2010/09/26/in-response-to.html">an earlier post</a>:</p>

<p style="text-align: center;"><img alt="The hyperoctahedral graph K_{2,2,2,2}" src="https://11011110.github.io/blog/assets/2010/k7/cocktail2.svg"/></p>

<p>If there are no two opposite vertices, we get  (a regular tetrahedron, again, but embedded in a four-dimensional way into the hypercube). Otherwise, we must take at least two pairs of opposite vertices to form a square, and the cases are  (only the square),  (a square pyramid),  (an octahedron), ,  (an octahedral pyramid), and  (the hyperoctahedron). All of these polyhedra can be represented as matching-mimicking networks with the additional property that all vertices are terminals:</p>

<p style="text-align: center;"><img alt="Matching-mimicking networks for up to four terminals" src="https://11011110.github.io/blog/assets/2019/4-terminal-mm.svg"/></p>

<p>Based on these small examples, it’s tempting to guess that when a pattern of matchings includes the empty set, the whole pattern is just the set of matchings on a graph whose edges are the pairs of terminals in the pattern. But it isn’t true. The square pyramid , for instance, can represent the pattern of matchings</p>



<p>with the empty set at the apex of the pyramid. In this pattern, even though one can match terminal pairs <span style="white-space: nowrap;">— or —,</span> one can’t take the union of those two matchings and cover all four terminals. (This is what you get by reflecting the two middle terminals of the network shown above for ; its matching-mimicking network is a tree with two interior non-terminals and four terminal leaves.) My guess is that the number of patterns of matching should grow quickly relative to the number of graphs, so for large enough numbers of terminals it should not be possible to use graphs without non-terminals or their complements. But I haven’t taken the case analysis far enough to find an example of this.</p>

<p>(<a href="https://mathstodon.xyz/@11011110/102160605632804102">Discuss on Mastodon</a>)</p></div>
    </content>
    <updated>2019-05-25T21:32:00Z</updated>
    <published>2019-05-25T21:32:00Z</published>
    <author>
      <name>David Eppstein</name>
    </author>
    <source>
      <id>https://11011110.github.io/blog/feed.xml</id>
      <author>
        <name>David Eppstein</name>
      </author>
      <link href="https://11011110.github.io/blog/feed.xml" rel="self" type="application/atom+xml"/>
      <link href="https://11011110.github.io/blog/" rel="alternate" type="text/html"/>
      <subtitle>Geometry, graphs, algorithms, and more</subtitle>
      <title>11011110</title>
      <updated>2019-05-28T06:05:39Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>https://eccc.weizmann.ac.il/report/2019/075</id>
    <link href="https://eccc.weizmann.ac.il/report/2019/075" rel="alternate" type="text/html"/>
    <title>TR19-075 |  Relations and Equivalences Between Circuit Lower Bounds and Karp-Lipton Theorems | 

	Lijie Chen, 

	Dylan McKay, 

	Cody Murray, 

	Ryan Williams</title>
    <summary>Relations and Equivalences Between Circuit Lower Bounds and Karp-Lipton Theorems

A frontier open problem in circuit complexity is to prove P^NP is not in SIZE[n^k] for all k; this is a necessary intermediate step towards NP is not in P/poly. Previously, for several classes containing P^NP, including NP^NP, ZPP^NP, and S_2 P, such lower bounds have been proved via Karp-Lipton-style Theorems: to prove C is not in SIZE[n^k] for all k, we show that C subset Ppoly implies a ``collapse'' D = C for some larger class D, where we already know D is not in SIZE[n^k] for all k. 

It seems obvious that one could take a different approach to prove circuit lower bounds for P^NP that does not require proving any Karp-Lipton-style theorems along the way. We show this intuition is wrong: (weak) Karp-Lipton-style theorems for P^NP are equivalent to fixed-polynomial size circuit lower bounds for P^NP. That is, P^NP not subset SIZE[n^k] for all k if and only if (NP is in P/poly implies PH is in i.o.-P^NP/n).
		
Next, we present new consequences of the assumption NP is in P/poly, towards proving similar results for NP circuit lower bounds. We show that under the assumption, fixed-polynomial circuit lower bounds for NP, nondeterministic polynomial-time derandomizations, and various fixed-polynomial time simulations of NP are all equivalent. Applying this equivalence, we show that circuit lower bounds for NP imply better Karp-Lipton collapses. That is, if NP is not in SIZE[n^k] for all k, then for all C in { ParP, PP, PSPACE, EXP }, C is in P/poly implies C is in i.o.-NP/n^eps for all eps &gt; 0. Note that unconditionally, the collapses are only to MA and not NP.
		
We also explore consequences of circuit lower bounds for a sparse language in NP. Among other results, we show if a polynomially-sparse NP language does not have n^(1+eps)-size circuits, then MA is in i.o.-NP/O(log n), MA is in i.o.-P^{NP[O(log n)]}, and NEXP is not in SIZE[2^o(m)]. Finally, we observe connections between these results and the ``hardness magnification'' phenomena described in recent works.</summary>
    <updated>2019-05-25T18:06:09Z</updated>
    <published>2019-05-25T18:06:09Z</published>
    <source>
      <id>https://eccc.weizmann.ac.il/</id>
      <author>
        <name>ECCC papers</name>
      </author>
      <link href="https://eccc.weizmann.ac.il/" rel="alternate" type="text/html"/>
      <link href="https://example.com/feeds/reports/" rel="self" type="application/atom+xml"/>
      <subtitle>Latest Reports published at https://eccc.weizmann.ac.il</subtitle>
      <title>ECCC - Reports</title>
      <updated>2019-05-28T19:21:01Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://rjlipton.wordpress.com/?p=15910</id>
    <link href="https://rjlipton.wordpress.com/2019/05/25/selected-papers-at-ccc-2019/" rel="alternate" type="text/html"/>
    <title>Selected Papers at CCC 2019</title>
    <summary>Some papers from the accepted list of this year’s Computational Complexity Conference [ UB CSE ] Alan Selman is a long-time friend of Ken and I, and is a long-time researcher in complexity theory. Alan was the first president of the organizing body for the Computational Complexity Conferences (CCC). Today we salute the th edition […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><font color="#0044cc"><br/>
<em>Some papers from the accepted list of this year’s Computational Complexity Conference</em><br/>
<font color="#000000"/></font></p><font color="#0044cc"><font color="#000000">
<table class="image alignright">
<tbody>
<tr>
<td>
<a href="https://rjlipton.wordpress.com/2019/05/25/selected-papers-at-ccc-2019/unknown-122/" rel="attachment wp-att-15912"><img alt="" class="alignright  wp-image-15912" src="https://rjlipton.files.wordpress.com/2019/05/unknown-1.jpeg?w=150" width="150"/></a>
</td>
</tr>
<tr>
<td class="caption alignright"><font size="-2">[ UB CSE ]</font></td>
</tr>
</tbody>
</table>
<p>
Alan Selman is a long-time friend of Ken and I, and is a long-time researcher in complexity theory. Alan was the first president of the organizing <a href="https://www.computationalcomplexity.org/governance.php">body</a> for the Computational Complexity Conferences (CCC). </p>
<p>
Today we salute the <img alt="{0b100010}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B0b100010%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{0b100010}"/>th edition of the conference and discuss some of the accepted papers.</p>
<p>
The conference, and the governing body, have changed names over the years; by any name it remains an important conference. Alan <a href="https://www.computationalcomplexity.org/documents/first-cfp.pdf">chaired</a> the first program committee with Steve Mahaney and <a href="https://dl.acm.org/citation.cfm?id=648296&amp;picked=prox">edited</a> the first proceedings, in 1986. </p>
<p>
Ken recently saw Alan two weeks ago at the banquet for the <a href="http://www.fields.utoronto.ca/activities/18-19/NP50">symposium</a> honoring Steve Cook at the University of Toronto. We will cover event, once <a href="https://rjlipton.wordpress.com/2019/05/21/making-up-tests/">exams</a> are done. Ken saw another of the CCC past presidents there—if you wish to guess who, a hint is it was one of Cook’s past students.</p>
<ul>
<li>
Dieter van Melkebeek, 2012-2018 <p/>
</li><li>
Peter Bro Miltersen, 2009-2012 <p/>
</li><li>
Pierre McKenzie, 2006-2009 <p/>
</li><li>
Lance Fortnow, 2000-2006 <p/>
</li><li>
Eric Allender, 1997-2000 <p/>
</li><li>
Steven Homer, 1994-1997 <p/>
</li><li>
Timothy Long, 1992-1994 <p/>
</li><li>
Stephen Mahaney, 1988-1992 <p/>
</li><li>
Alan Selman, 1985-1988
</li></ul>
<p>
Although we do not usually do announcements, we note from the conference <a href="https://computationalcomplexity.org">website</a>:</p>
<blockquote><p><b> </b> <em> Details of the local arrangements for CCC 2019 and the preceding events, including the DIMACS Day of Tutorials, are available. Early registration runs till June 26. </em>
</p></blockquote>
<p>
</p><p/><h2> Six Papers with Some Comments </h2><p/>
<p/><p>
Here are some papers that I, Dick, found interesting from the list of accepted papers. All accepted papers are interesting, of course. I selected six that were on topics that were directly connected with my interests.</p>
<p>
<b>Criticality of Regular Formulas</b>—<a href="http://www.math.toronto.edu/rossman/criticality.pdf">paper</a><br/>
Benjamin Rossman<br/>
<i>I thought this was about regular expressions. Shows something about me.</i> Here “regular” means the in-degree of gates being the same at each level of the circuit. This condition seems likely to be removable as Rossman conjectures, but I doubt it will be easy. The term “criticality” is a parameter that measures how much a random restriction reduces the size of a formula. Think switching lemma.</p>
<p>
<b>Typically-Correct Derandomization for Small Time and Space</b>—<a href="https://arxiv.org/abs/1711.00565">paper</a><br/>
William Hoza<br/>
<i>I like the notion of typically-correct.</i> Their algorithms work by treating the input as a source of randomness. This idea was pioneered by Oded Goldreich and Avi Wigderson. The title of their 2002 <a href="http://www.wisdom.weizmann.ac.il/~oded/p_rnd02.html">article</a> “Derandomization that is rarely wrong from short advice that is typically good”, gives away how one can prove such results. </p>
<p>
<b>Optimal Short-Circuit Resilient Formulas</b>—<a href="https://arxiv.org/abs/1807.05014">paper</a><br/>
Mark Braverman, Klim Efremenko, Ran Gelles, and Michael Yitayew <br/>
<i>This is on a kind of fault-tolerance.</i> They consider fault-tolerant boolean formulas in which the output of a faulty gate is stuck at one of the gate’s inputs. This is an interesting model of errors, and they show roughly: any formula can be converted into a formula that is not too much bigger and survives even if about <img alt="{1/5}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B1%2F5%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{1/5}"/> of the gates are faulty. A surprise is that they use a method related to <i>blockchains</i>. Hmmmmm. Interesting.</p>
<p>
<b>Fourier and Circulant Matrices are Not Rigid</b>—<a href="https://arxiv.org/pdf/1902.07334.pdf">paper</a><br/>
Allen Liu and Zeev Dvir <br/>
<i>A matrix is rigid if its rank cannot be reduced significantly by changing a small number of entries.</i> As you probably know there are plenty of rigid matrices—take random ones—but no provable examples of explicit ones. Their beautiful results prove that specific families of matrices are not rigid. These families include ones that were long thought to be rigid. The highlight of this work could be that it suggests new families that may be rigid. </p>
<p>
<b>Average-Case Quantum Advantage with Shallow Circuits</b>—<a href="https://arxiv.org/pdf/1810.12792.pdf">paper</a><br/>
François Le Gall <br/>
<i>A quest, the quest that tops all others—is the search for evidence that quantum computers are better than classic ones.</i> Of course, this is nearly impossible, since P=PSPACE is an open problem. So one looks at special classes of computations. See <a href="https://arxiv.org/pdf/1612.05903.pdf">here</a> for how the quest for “quantum advantage” meets up with computational complexity.</p>
<p>
<b>Relations and Equivalences Between Circuit Lower Bounds and Karp-Lipton Theorems</b><br/>
<a href="https://eccc.weizmann.ac.il/report/2019/075/">paper</a><br/>
Lijie Chen, Dylan McKay, Cody Murray, and Ryan Williams <br/>
<i>Of course I think this is an interesting paper.</i> There is the famous H-score. Perhaps there could be a T-score. This would be the number of times your name is in the title of a published paper. Thus Ron Rivest, for example, has a huge T-score.</p>
<p>
</p><p/><h2> Open Problems </h2><p/>
<p/><p>
What are your selected papers? </p>
<p>
[Added link to Relations and Equivalences… paper]</p></font></font></div>
    </content>
    <updated>2019-05-25T15:10:21Z</updated>
    <published>2019-05-25T15:10:21Z</published>
    <category term="Ideas"/>
    <category term="News"/>
    <category term="Open Problems"/>
    <category term="Results"/>
    <category term="complexity"/>
    <category term="conferences"/>
    <category term="papers"/>
    <category term="selected"/>
    <category term="Selman"/>
    <author>
      <name>rjlipton</name>
    </author>
    <source>
      <id>https://rjlipton.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://rjlipton.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://rjlipton.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://rjlipton.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://rjlipton.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>a personal view of the theory of computation</subtitle>
      <title>Gödel’s Lost Letter and P=NP</title>
      <updated>2019-05-28T19:21:15Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-3722233.post-4982821151012814632</id>
    <link href="https://blog.computationalcomplexity.org/feeds/4982821151012814632/comments/default" rel="replies" type="application/atom+xml"/>
    <link href="https://blog.computationalcomplexity.org/2019/05/logic-then-and-now.html#comment-form" rel="replies" type="text/html"/>
    <link href="https://www.blogger.com/feeds/3722233/posts/default/4982821151012814632" rel="edit" type="application/atom+xml"/>
    <link href="https://www.blogger.com/feeds/3722233/posts/default/4982821151012814632" rel="self" type="application/atom+xml"/>
    <link href="https://blog.computationalcomplexity.org/2019/05/logic-then-and-now.html" rel="alternate" type="text/html"/>
    <title>Logic Then and Now</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">This week I attended the <a href="https://asl2019.commons.gc.cuny.edu/">Association of Symbolic Logic North American Annual Meeting</a> in New York City, giving a talk on P v NP.<br/>
<br/>
First I must share the announcement that ASL member Tuna Antinel of Lyon 1 University has been arrested in Turkey for his political beliefs. <a href="http://math.univ-lyon1.fr/SoutienTunaAltinel/">This website</a> (<a href="https://webusers.imj-prg.fr/~adrien.deloro/">English version</a>) has details and how to show your support.<br/>
<br/>
I last attended the ASL annual meeting at Notre Dame in 1993 as a young assistant professor. Back then I talked about <a href="https://doi.org/10.1137/S0097539793248305">then recent work</a> using a special kind of generic oracle to make the Berman-Hartmanis isomorphism conjecture true. I remember someone coming up to me after the talk saying how excited they were to see such applications of logic. I'm not a theoretical computer scientist, I'm a applied logician.<br/>
<br/>
I asked at my talk this year and maybe 2-3 people were at that 1993 meeting. The attendance seemed smaller and younger, though that could be my memory playing tricks. I heard that the 2018 meeting in Macomb, Illinois drew a larger crowd. New York is expensive and logicians don't get large travel budgets.<br/>
<br/>
Logic like theoretical computer science has gotten more specialized so I was playing catch up trying to follow many of the talks. Mariya Soskova of Wisconsin talked about enumeration degrees that brought me back to the days I sat in logic classes and talks at the University of Chicago. A set A is enumeration reducible to B if from an enumeration of B you can compute an enumeration of A and Mariya gave a great overview of this area.<br/>
<br/>
I learned about the status of an open problem for Turing reducibility: Is there a non-trivial automorphism of the Turing Degrees? A degree is the equivalence class where each class are the languages all computably Turing-reducible to each other. So the question asks if there is a bijection f mapping degrees to degrees, other than identity, that preserves reducibility or lack thereof.<br/>
<br/>
Here's what's known: There are countably many such automorphisms. There is a definable degree C in the arithmetic hierarchy, such that if f(C) = C then f is the identity. Also if f is the identity on all the c.e.-degrees (those equivalence classes containing a computably enumerable set), then f is the identity on all the degrees. Still open if there is more than one automorphism.<br/>
<br/>
<br/></div>
    </content>
    <updated>2019-05-24T13:14:00Z</updated>
    <published>2019-05-24T13:14:00Z</published>
    <author>
      <name>Lance Fortnow</name>
      <email>noreply@blogger.com</email>
      <uri>http://www.blogger.com/profile/06752030912874378610</uri>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-3722233</id>
      <category term="typecast"/>
      <category term="focs metacomments"/>
      <author>
        <name>Lance Fortnow</name>
        <email>noreply@blogger.com</email>
        <uri>http://www.blogger.com/profile/06752030912874378610</uri>
      </author>
      <link href="https://blog.computationalcomplexity.org/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/>
      <link href="https://www.blogger.com/feeds/3722233/posts/default" rel="self" type="application/atom+xml"/>
      <link href="https://blog.computationalcomplexity.org/" rel="alternate" type="text/html"/>
      <link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/>
      <link href="https://www.blogger.com/feeds/3722233/posts/default?start-index=26&amp;max-results=25" rel="next" type="application/atom+xml"/>
      <subtitle>Computational Complexity and other fun stuff in math and computer science from Lance Fortnow and Bill Gasarch</subtitle>
      <title>Computational Complexity</title>
      <updated>2019-05-28T08:16:52Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://tcsplus.wordpress.com/?p=355</id>
    <link href="https://tcsplus.wordpress.com/2019/05/22/tcs-talk-wednesday-may-29th-lior-kamma-aarhus-university/" rel="alternate" type="text/html"/>
    <title>TCS+ talk: Wednesday, May 29th — Lior Kamma, Aarhus University</title>
    <summary>The next TCS+ talk will take place this coming Wednesday, May 29th at 1:00 PM Eastern Time (10:00 AM Pacific Time, 18:00 Central European Time, 19:00 Central European Summer Time, 17:00 UTC). Lior Kamma from Aarhus University will speak about “Lower Bounds for Multiplication via Network Coding” (abstract below). Please make sure you reserve a […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>The next TCS+ talk will take place this coming Wednesday, May 29th at 1:00 PM Eastern Time (10:00 AM Pacific Time, 18:00 Central European Time, 19:00 Central European Summer Time, 17:00 UTC). <strong>Lior Kamma</strong> from Aarhus University will speak about “<em>Lower Bounds for Multiplication via Network Coding</em>” (abstract below).</p>
<p>Please make sure you reserve a spot for your group to join us live by signing up on <a href="https://sites.google.com/site/plustcs/livetalk/live-seat-reservation">the online form</a>. As usual, for more information about the TCS+ online seminar series and the upcoming talks, or to <a href="https://sites.google.com/site/plustcs/suggest">suggest</a> a possible topic or speaker, please see <a href="https://sites.google.com/site/plustcs/">the website</a>.</p>
<blockquote><p>Abstract: Multiplication is one of the most fundamental computational problems, yet its true complexity remains elusive. The best known upper bound, very recently proved by Harvey and Van Der Hoven shows that two <img alt="n" class="latex" src="https://s0.wp.com/latex.php?latex=n&amp;bg=fff&amp;fg=444444&amp;s=0" title="n"/>-bit numbers can be multiplied via a boolean circuit of size <img alt="O(n \lg n)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n+%5Clg+n%29&amp;bg=fff&amp;fg=444444&amp;s=0" title="O(n \lg n)"/>.</p>
<p>We prove that if a central conjecture in the area of network coding is true, then any constant degree Boolean circuit for multiplication must have size <img alt="\Omega(n \lg n)" class="latex" src="https://s0.wp.com/latex.php?latex=%5COmega%28n+%5Clg+n%29&amp;bg=fff&amp;fg=444444&amp;s=0" title="\Omega(n \lg n)"/>, thus (conditioned on the conjecture) completely settling the complexity of multiplication circuits. We additionally revisit classic conjectures in circuit complexity, due to Valiant, and show that the network coding conjecture also implies one of Valiant’s conjectures.</p>
<p>Joint work with Peyman Afshani, Casper Freksen and Kasper Green Larsen</p></blockquote>
<p><span id="more-355"/></p></div>
    </content>
    <updated>2019-05-22T20:56:24Z</updated>
    <published>2019-05-22T20:56:24Z</published>
    <category term="Announcements"/>
    <author>
      <name>plustcs</name>
    </author>
    <source>
      <id>https://tcsplus.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://tcsplus.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://tcsplus.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://tcsplus.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://tcsplus.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A carbon-free dissemination of ideas across the globe.</subtitle>
      <title>TCS+</title>
      <updated>2019-05-28T19:23:07Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://emanueleviola.wordpress.com/?p=639</id>
    <link href="https://emanueleviola.wordpress.com/2019/05/22/statement-of-concern-regarding-marijuana-in-massachusetts/" rel="alternate" type="text/html"/>
    <title>Statement of concern regarding Marijuana in Massachusetts</title>
    <summary>You can read it here. If you don’t want to click, some key takeaways are: We disagree with how marijuana policy is being shaped in the Commonwealth. The science is clear; marijuana, specifically the psychoactive chemical THC (delta-9-tetrahydrocannabinol), has the potential to do significant harm to public health. Diversion of high THC products (≥10%), vapes […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>You can read it <a href="https://gallery.mailchimp.com/d93a0b5fcff1daf7b38ecd20c/files/4a4118a7-45ed-4910-b3d1-c64a5e822417/MA_MJ_Policy_Statement_of_Concern_5_9_19_FINAL.pdf">here</a>. If you don’t want to click, some key takeaways are:</p>
<ul>
<li><span class="fontstyle0">We disagree with how marijuana policy is being shaped in the Commonwealth.</span></li>
<li><span class="fontstyle0">The science is clear; marijuana, specifically the psychoactive chemical THC (delta-9-tetrahydrocannabinol), has the potential to do significant harm to public health.</span></li>
<li><span class="fontstyle0">Diversion of high THC products (≥10%), vapes and edibles, to MA youth is a growing concern.</span></li>
<li><span class="fontstyle0">When public health is not prioritized in the regulation of addictive substances, the public and our young people are put at risk.</span></li>
</ul>
<p>You can also find in the statement a list of negative effects of THC.  This is all signed by a dozen+ doctors. The various marijuana players with zero medical knowledge will probably dismiss the experts’ opinion with, at best, a shrug. Instead, they are looking into opening <a href="https://www.boston.com/news/local-news/2019/05/16/massachusetts-marijuana-cafes-social-consumption">marijuana cafes</a>. And the first marijuana retail store will open in Newton <a href="https://patch.com/massachusetts/newton/newtons-first-recreational-marijuana-shop-has-grand-opening-date">this Saturday</a>.</p>
<p>If you want to get even more worked up about marijuana reading my <a href="https://emanueleviola.wordpress.com/2019/01/27/selling-your-town-to-the-marijuana-industry/">previous post</a> might help.</p>
<p>Finally, <a href="http://www.mapreventionalliance.org/">on June 5^th there will be a luncheon event at the JFK Library titled: Marijuana: Addiction, Mental Health and Policy – Advances in Research…What have we learned in the past 5 years?</a></p></div>
    </content>
    <updated>2019-05-22T19:45:31Z</updated>
    <published>2019-05-22T19:45:31Z</published>
    <category term="Uncategorized"/>
    <category term="health"/>
    <category term="marijuana"/>
    <author>
      <name>Emanuele</name>
    </author>
    <source>
      <id>https://emanueleviola.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://emanueleviola.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://emanueleviola.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://emanueleviola.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://emanueleviola.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>by Manu</subtitle>
      <title>Thoughts</title>
      <updated>2019-05-28T19:22:18Z</updated>
    </source>
  </entry>
</feed>
