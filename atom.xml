<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/" xmlns:indexing="urn:atom-extension:indexing" indexing:index="no"><access:restriction xmlns:access="http://www.bloglines.com/about/specs/fac-1.0" relationship="deny"/>
  <title>Theory of Computing Blog Aggregator</title>
  <updated>2020-02-13T12:21:45Z</updated>
  <generator uri="http://intertwingly.net/code/venus/">Venus</generator>
  <author>
    <name>Arnab Bhattacharyya, Suresh Venkatasubramanian</name>
    <email>arbhat+cstheoryfeed@gmail.com</email>
  </author>
  <id>http://www.cstheory-feed.org/atom.xml</id>
  <link href="http://www.cstheory-feed.org/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="http://www.cstheory-feed.org/" rel="alternate"/>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05156</id>
    <link href="http://arxiv.org/abs/2002.05156" rel="alternate" type="text/html"/>
    <title>Public Bayesian Persuasion: Being Almost Optimal and Almost Persuasive</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/c/Castiglioni:Matteo.html">Matteo Castiglioni</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/c/Celli:Andrea.html">Andrea Celli</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Gatti:Nicola.html">Nicola Gatti</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05156">PDF</a><br/><b>Abstract: </b>Persuasion studies how an informed principal may influence the behavior of
agents by the strategic provision of payoff-relevant information. We focus on
the fundamental multi-receiver model by Arieli and Babichenko (2019), in which
there are no inter-agent externalities. Unlike prior works on this problem, we
study the public persuasion problem in the general setting with: (i) arbitrary
state spaces; (ii) arbitrary action spaces; (iii) arbitrary sender's utility
functions. We fully characterize the computational complexity of computing a
bi-criteria approximation of an optimal public signaling scheme. In particular,
we show, in a voting setting of independent interest, that solving this problem
requires at least a quasi-polynomial number of steps even in settings with a
binary action space, assuming the Exponential Time Hypothesis. In doing so, we
prove that a relaxed version of the Maximum Feasible Subsystem of Linear
Inequalities problem requires at least quasi-polynomial time to be solved.
Finally, we close the gap by providing a quasi-polynomial time bi-criteria
approximation algorithm for arbitrary public persuasion problems that, in
specific settings, yields a QPTAS.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05139</id>
    <link href="http://arxiv.org/abs/2002.05139" rel="alternate" type="text/html"/>
    <title>List-Decodable Subspace Recovery via Sum-of-Squares</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Bakshi:Ainesh.html">Ainesh Bakshi</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kothari:Pravesh.html">Pravesh Kothari</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05139">PDF</a><br/><b>Abstract: </b>We give the first efficient algorithm for the problem of list-decodable
subspace recovery. Our algorithm takes input $n$ samples $\alpha n$ ($\alpha\ll
1/2$) are generated i.i.d. from Gaussian distribution $\mathcal{N}(0,\Sigma_*)$
on $\mathbb{R}^d$ with covariance $\Sigma_*$ of rank $r$ and the rest are
arbitrary, potentially adversarial outliers. It outputs a list of $O(1/\alpha)$
projection matrices guaranteed to contain a projection matrix $\Pi$ such that
$\|\Pi-\Pi_*\|_F^2 = \kappa^4 \log (r) \tilde{O}(1/\alpha^2)$, where
$\tilde{O}$ hides polylogarithmic factors in $1/\alpha$. Here, $\Pi_*$ is the
projection matrix to the range space of $\Sigma_*$. The algorithm needs
$n=d^{\log (r \kappa) \tilde{O}(1/\alpha^2)}$ samples and runs in time $n^{\log
(r \kappa) \tilde{O}(1/\alpha^4)}$ time where $\kappa$ is the ratio of the
largest to smallest non-zero eigenvalues of $\Sigma_*$.
</p>
<p>Our algorithm builds on the recently developed framework for list-decodable
learning via the sum-of-squares (SoS) method [KKK'19, RY'20] with some key
technical and conceptual advancements. Our key conceptual contribution involves
showing a (SoS "certified") lower bound on the eigenvalues of covariances of
arbitrary small subsamples of an i.i.d. sample of a certifiably
anti-concentrated distribution. One of our key technical contributions gives a
new method that allows error reduction "within SoS" with only a logarithmic
cost in the exponent in the running time (in contrast to polynomial cost in
[KKK'19, RY'20].
</p>
<p>In a concurrent and independent work, Raghavendra and Yau proved related
results for list-decodable subspace recovery [RY'20].
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05131</id>
    <link href="http://arxiv.org/abs/2002.05131" rel="alternate" type="text/html"/>
    <title>Recursed is not Recursive: A Jarring Result</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Erik Demaine, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kopinsky:Justin.html">Justin Kopinsky</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lynch:Jayson.html">Jayson Lynch</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05131">PDF</a><br/><b>Abstract: </b>Recursed is a 2D puzzle platform video game featuring treasure chests that,
when jumped into, instantiate a room that can later be exited (similar to
function calls), optionally generating a \jar that returns back to that room
(similar to continuations). We prove that Recursed is RE-complete and thus
undecidable (not recursive) by a reduction from the Post Correspondence
Problem. Our reduction is "practical": the reduction from PCP results in fully
playable levels that abide by all constraints governing levels (including the
15x20 room size) designed for the main game. Our reduction is also "efficient":
a Turing machine can be simulated by a Recursed level whose size is linear in
the encoding size of the Turing machine and whose solution length is polynomial
in the running time of the Turing machine.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05129</id>
    <link href="http://arxiv.org/abs/2002.05129" rel="alternate" type="text/html"/>
    <title>Batch-dynamic Algorithms via Parallel Change Propagation and Applications to Dynamic Trees</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/a/Acar:Umut_A=.html">Umut A. Acar</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/a/Anderson:Daniel.html">Daniel Anderson</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Blelloch:Guy_E=.html">Guy E. Blelloch</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/d/Dhulipala:Laxman.html">Laxman Dhulipala</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/w/Westrick:Sam.html">Sam Westrick</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05129">PDF</a><br/><b>Abstract: </b>Dynamic algorithms capable of supporting batches of updates are increasingly
relevant today due to the emergence of rapidly-evolving dynamic datasets. Since
processing updates on a single processor is often unrealistic for large batches
of updates, designing parallel dynamic algorithms that achieve provably low
span is important for many applications. In this paper, motivated by the
difficulty in designing parallel batch-dynamic algorithms by hand, we propose a
framework for algorithmically dynamizing static round-synchronous algorithms to
obtain parallel batch-dynamic algorithms with good bounds on their work and
span.
</p>
<p>In our framework, the algorithm designer can apply the technique to any
suitably defined static algorithm. We then obtain theoretical guarantees for
algorithms in our framework by defining the notion of a computation distance
between two executions of the underlying algorithm.
</p>
<p>Using this framework, we develop the first work-efficient parallel
batch-dynamic algorithm for dynamic trees that supports both subtree queries
and path queries, as well as a variety of nonlocal queries such as centers and
medians. We further investigate the applicability of the framework by analyzing
map-reduce-based computations, and a random-mate list contraction algorithm,
which, when dynamized, yields a simple solution to the batch-dynamic lists
problem that matches the work bounds of the best known hand-crafted data
structure.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05121</id>
    <link href="http://arxiv.org/abs/2002.05121" rel="alternate" type="text/html"/>
    <title>An Optimal Decentralized $(\Delta + 1)$-Coloring Algorithm</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Daniel Bertschinger, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lengler:Johannes.html">Johannes Lengler</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/Martinsson:Anders.html">Anders Martinsson</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/Meier:Robert.html">Robert Meier</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Steger:Angelika.html">Angelika Steger</a>, Miloš Trujić, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/w/Welzl:Emo.html">Emo Welzl</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05121">PDF</a><br/><b>Abstract: </b>Consider the following simple coloring algorithm for a graph on $n$ vertices.
Each vertex chooses a color from $\{1, \dotsc, \Delta(G) + 1\}$ uniformly at
random. While there exists a conflicted vertex choose one such vertex uniformly
at random and recolor it with a randomly chosen color. This algorithm was
introduced by Bhartia et al. [MOBIHOC'16] for channel selection in
WIFI-networks. We show that this algorithm always converges to a proper
coloring in expected $O(n \log \Delta)$ steps, which is optimal and proves a
conjecture of Chakrabarty and Supinski [SOSA'20].
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05071</id>
    <link href="http://arxiv.org/abs/2002.05071" rel="alternate" type="text/html"/>
    <title>HushRelay: A Privacy-Preserving, Efficient, and Scalable Routing Algorithm for Off-Chain Payments</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/Mazumdar:Subhra.html">Subhra Mazumdar</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/r/Ruj:Sushmita.html">Sushmita Ruj</a>, Ram Govind Singh, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Pal:Arindam.html">Arindam Pal</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05071">PDF</a><br/><b>Abstract: </b>Payment channel networks (PCN) are used in cryptocurrencies to enhance the
performance and scalability of off-chain transactions. Except for opening and
closing of a payment channel, no other transaction requests accepted by a PCN
are recorded in the Blockchain. Only the parties which have opened the channel
will know the exact amount of fund left at a given instant. In real scenarios,
there might not exist a single path which can enable transfer of high value
payments. For such cases, splitting up the transaction value across multiple
paths is a better approach. While there exists several approaches which route
transactions via several paths, such techniques are quite inefficient, as the
decision on the number of splits must be taken at the initial phase of the
routing algorithm (e.g., SpeedyMurmur [42]). Algorithms which do not consider
the residual capacity of each channel in the network are susceptible to
failure. Other approaches leak sensitive information, and are quite
computationally expensive [28]. To the best of our knowledge, our proposed
scheme HushRelay is an efficient privacy preserving routing algorithm, taking
into account the funds left in each channel, while splitting the transaction
value across several paths. Comparing the performance of our algorithm with
existing routing schemes on real instances (e.g., Ripple Network), we observed
that HushRelay attains a success ratio of 1, with an execution time of 2.4 sec.
However, SpeedyMurmur [42] attains a success ratio of 0.98 and takes 4.74 sec
when the number of landmarks is 6. On testing our proposed routing algorithm on
the Lightning Network, a success ratio of 0.99 is observed, having an execution
time of 0.15 sec, which is 12 times smaller than the time taken by
SpeedyMurmur.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05068</id>
    <link href="http://arxiv.org/abs/2002.05068" rel="alternate" type="text/html"/>
    <title>Complexity of Combinatorial Matrix Completion With Diameter Constraints</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Koana:Tomohiro.html">Tomohiro Koana</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/f/Froese:Vincent.html">Vincent Froese</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/n/Niedermeier:Rolf.html">Rolf Niedermeier</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05068">PDF</a><br/><b>Abstract: </b>We thoroughly study a novel and still basic combinatorial matrix completion
problem: Given a binary incomplete matrix, fill in the missing entries so that
the resulting matrix has a specified maximum diameter (that is, upper-bounding
the maximum Hamming distance between any two rows of the completed matrix) as
well as a specified minimum Hamming distance between any two of the matrix
rows. This scenario is closely related to consensus string problems as well as
to recently studied clustering problems on incomplete data.
</p>
<p>We obtain an almost complete complexity dichotomy between polynomial-time
solvable and NP-hard cases in terms of the minimum distance lower bound and the
number of missing entries per row of the incomplete matrix. Further, we develop
polynomial-time algorithms for maximum diameter three, which are based on
Deza's theorem from extremal set theory. On the negative side we prove
NP-hardness for diameter at least four. For the parameter number of missing
entries per row, we show polynomial-time solvability when there is only one
missing entry and NP-hardness when there can be at least two missing entries.
In general, our algorithms heavily rely on Deza's theorem and the
correspondingly identified sunflower structures pave the way towards solutions
based on computing graph factors and solving 2-SAT instances.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05056</id>
    <link href="http://arxiv.org/abs/2002.05056" rel="alternate" type="text/html"/>
    <title>Quantum Boosting</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/a/Arunachalam:Srinivasan.html">Srinivasan Arunachalam</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/Maity:Reevu.html">Reevu Maity</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05056">PDF</a><br/><b>Abstract: </b>Suppose we have a weak learning algorithm $\mathcal{A}$ for a Boolean-valued
problem: $\mathcal{A}$ produces hypotheses whose bias $\gamma$ is small, only
slightly better than random guessing (this could, for instance, be due to
implementing $\mathcal{A}$ on a noisy device), can we boost the performance of
$\mathcal{A}$ so that $\mathcal{A}$'s output is correct on $2/3$ of the inputs?
</p>
<p>Boosting is a technique that converts a weak and inaccurate machine learning
algorithm into a strong accurate learning algorithm. The AdaBoost algorithm by
Freund and Schapire (for which they were awarded the G\"odel prize in 2003) is
one of the widely used boosting algorithms, with many applications in theory
and practice. Suppose we have a $\gamma$-weak learner for a Boolean concept
class $C$ that takes time $R(C)$, then the time complexity of AdaBoost scales
as $VC(C)\cdot poly(R(C), 1/\gamma)$, where $VC(C)$ is the $VC$-dimension of
$C$. In this paper, we show how quantum techniques can improve the time
complexity of classical AdaBoost. To this end, suppose we have a $\gamma$-weak
quantum learner for a Boolean concept class $C$ that takes time $Q(C)$, we
introduce a quantum boosting algorithm whose complexity scales as
$\sqrt{VC(C)}\cdot poly(Q(C),1/\gamma);$ thereby achieving a quadratic quantum
improvement over classical AdaBoost in terms of $VC(C)$.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.05034</id>
    <link href="http://arxiv.org/abs/2002.05034" rel="alternate" type="text/html"/>
    <title>Uniform Linked Lists Contraction</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Han:Yijie.html">Yijie Han</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.05034">PDF</a><br/><b>Abstract: </b>We present a parallel algorithm (EREW PRAM algorithm) for linked lists
contraction. We show that when we contract a linked list from size $n$ to size
$n/c$ for a suitable constant $c$ we can pack the linked list into an array of
size $n/d$ for a constant $1 &lt; d\leq c$ in the time of 3 coloring the list.
Thus for a set of linked lists with a total of $n$ elements and the longest
list has $l$ elements our algorithm contracts them in $O(n\log
i/p+(\log^{(i)}n+\log i )\log \log l+ \log l)$ time, for an arbitrary
constructible integer $i$, with $p$ processors on the EREW PRAM, where
$\log^{(1)} n =\log n$ and $\log^{(t)}n=\log \log^{(t-1)} n$ and $\log^*n=\min
\{ i|\log^{(i)} n &lt; 10\}$. When $i$ is a constant we get time
$O(n/p+\log^{(i)}n\log \log l+\log l)$. Thus when $l=\Omega (\log^{(c)}n)$ for
any constant $c$ we achieve $O(n/p+\log l)$ time. The previous best
deterministic EREW PRAM algorithm has time $O(n/p+\log n)$ and best CRCW PRAM
algorithm has time $O(n/p+\log n/\log \log n+\log l)$.
</p>
<p>Keywords: Parallel algorithms, linked list, linked list contraction, uniform
linked list contraction, EREW PRAM.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04989</id>
    <link href="http://arxiv.org/abs/2002.04989" rel="alternate" type="text/html"/>
    <title>Eigenvector Component Calculation Speedup over NumPy for High Performance Computing</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Shrey Dabhi, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Parmar:Manojkumar.html">Manojkumar Parmar</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04989">PDF</a><br/><b>Abstract: </b>Applications related to artificial intelligence, machine learning and system
identification simulations essentially use eigenvectors. Calculating
eigenvectors for very large matrices using conventional methods is compute
intensive and renders the applications slow. Recently, Eigenvector-Eigenvalue
Identity formula promising significant speed up was identified. We study the
algorithmic implementation of the formula against the existing state-of-the-art
algorithms and their implementations to evaluate the performance gains. We
provide a first of it's kind systematic study of the implementation of the
formula. We demonstrate further improvements using high performance computing
concepts over native NumPy eigenvector implementation which uses LAPACK and
BLAS.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04979</id>
    <link href="http://arxiv.org/abs/2002.04979" rel="alternate" type="text/html"/>
    <title>On Rearrangement of Items Stored in Stacks</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Szegedy:Mario.html">Mario Szegedy</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/y/Yu:Jingjin.html">Jingjin Yu</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04979">PDF</a><br/><b>Abstract: </b>There are $n \ge 2$ stacks, each filled with $d$ items (its full capacity),
and one empty stack with capacity $d$. A robot arm, in one stack operation
(move), may pop one item from the top of a non-empty stack and subsequently
push it into a stack that is not at capacity. In a {\em labeled} problem, all
$nd$ items are distinguishable and are initially randomly scattered in the $n$
stacks. The items must be rearranged using pop-and-push moves so that at the
end, the $k^{\rm th}$ stack holds items $(k-1)d +1, \ldots, kd$, in that order,
from the top to the bottom for all $1 \le k \le n$. In an {\em unlabeled}
problem, the $nd$ items are of $n$ types of $d$ each. The goal is to rearrange
items so that items of type $k$ are located in the $k^{\rm th}$ stack for all
$1 \le k \le n$. In carrying out the rearrangement, a natural question is to
find the least number of required pop-and-push moves.
</p>
<p>In terms of the required number of moves for solving the rearrangement
problems, the labeled and unlabeled version have lower bounds $\Omega(nd +
nd{\frac{\log d}{\log n}})$ and $\Omega(nd)$, respectively. Our main
contribution is the design of an algorithm with a guaranteed upper bound of
$O(nd)$ for both versions when $d \le cn$ for arbitrary fixed positive number
$c$. In addition, a subroutine for a problem that we call the Rubik table
problem is of independent interest, with applications to problems including
multi-robot motion planning.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04894</id>
    <link href="http://arxiv.org/abs/2002.04894" rel="alternate" type="text/html"/>
    <title>Distributed and Adaptive Fast Multipole Method In Three Dimensions</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Bull:Jonathan.html">Jonathan Bull</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/e/Engblom:Stefan.html">Stefan Engblom</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04894">PDF</a><br/><b>Abstract: </b>We develop a general distributed implementation of an adaptive fast multipole
method in three space dimensions. We rely on a balanced type of adaptive space
discretisation which supports a highly transparent and fully distributed
implementation. A complexity analysis indicates favorable scaling properties
and numerical experiments on up to 512 cores and 1 billion source points verify
them. The parameters controlling the algorithm are subject to in-depth
experiments and the performance response to the input parameters implies that
the overall implementation is well-suited to automated tuning.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04870</id>
    <link href="http://arxiv.org/abs/2002.04870" rel="alternate" type="text/html"/>
    <title>On the I/O complexity of the k-nearest neighbor problem</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Goswami:Mayank.html">Mayank Goswami</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/j/Jacob:Riko.html">Riko Jacob</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Pagh:Rasmus.html">Rasmus Pagh</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04870">PDF</a><br/><b>Abstract: </b>We consider static, external memory indexes for exact and approximate
versions of the $k$-nearest neighbor ($k$-NN) problem, and show new lower
bounds under a standard indivisibility assumption:
</p>
<p>- Polynomial space indexing schemes for high-dimensional $k$-NN in Hamming
space cannot take advantage of block transfers: $\Omega(k)$ block reads are
needed to to answer a query.
</p>
<p>- For the $\ell_\infty$ metric the lower bound holds even if we allow
$c$-appoximate nearest neighbors to be returned, for $c \in (1, 3)$.
</p>
<p>- The restriction to $c &lt; 3$ is necessary: For every metric there exists an
indexing scheme in the indexability model of Hellerstein et al.~using space
$O(kn)$, where $n$ is the number of points, that can retrieve $k$ 3-approximate
nearest neighbors using $\lceil k/B\rceil$ I/Os, which is optimal.
</p>
<p>- For specific metrics, data structures with better approximation factors are
possible. For $k$-NN in Hamming space and every approximation factor $c&gt;1$
there exists a polynomial space data structure that returns $k$ $c$-approximate
nearest neighbors in $\lceil k/B\rceil$ I/Os.
</p>
<p>To show these lower bounds we develop two new techniques: First, to handle
that approximation algorithms have more freedom in deciding which result set to
return we develop a relaxed version of the $\lambda$-set workload technique of
Hellerstein et al. This technique allows us to show lower bounds that hold in
$d\geq n$ dimensions. To extend the lower bounds down to $d = O(k \log(n/k))$
dimensions, we develop a new deterministic dimension reduction technique that
may be of independent interest.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04850</id>
    <link href="http://arxiv.org/abs/2002.04850" rel="alternate" type="text/html"/>
    <title>The {0,1}-knapsack problem with qualitative levels</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Sch=auml=fer:Luca_E=.html">Luca E. Schäfer</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/d/Dietz:Tobias.html">Tobias Dietz</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Barbati:Maria.html">Maria Barbati</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/f/Figueira:Jos=eacute=_Rui.html">José Rui Figueira</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Greco:Salvatore.html">Salvatore Greco</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/r/Ruzika:Stefan.html">Stefan Ruzika</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04850">PDF</a><br/><b>Abstract: </b>A variant of the classical knapsack problem is considered in which each item
is associated with an integer weight and a qualitative level. We define a
dominance relation over the feasible subsets of the given item set and show
that this relation defines a preorder. We propose a dynamic programming
algorithm to compute the entire set of non-dominated rank cardinality vectors
and we state two greedy algorithms, which efficiently compute a single
efficient solution.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04841</id>
    <link href="http://arxiv.org/abs/2002.04841" rel="alternate" type="text/html"/>
    <title>Optimal Label Splitting for Embedding an LTS into an arbitrary Petri Net Reachability Graph is NP-complete</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Schlachter:Uli.html">Uli Schlachter</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/w/Wimmel:Harro.html">Harro Wimmel</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04841">PDF</a><br/><b>Abstract: </b>For a given labelled transition system (LTS), synthesis is the task to find
an unlabelled Petri net with an isomorphic reachability graph. Even when just
demanding an embedding into a reachability graph instead of an isomorphism, a
solution is not guaranteed. In such a case, label splitting is an option, i.e.
relabelling edges of the LTS such that differently labelled edges remain
different. With an appropriate label splitting, we can always obtain a solution
for the synthesis or embedding problem. Using the label splitting, we can
construct a labelled Petri net with the intended bahaviour (e.g. embedding the
given LTS in its reachability graph). As the labelled Petri net can have a
large number of transitions, an optimisation may be desired, limiting the
number of labels produced by the label splitting. We show that such a
limitation will turn the problem from being solvable in polynomial time into an
NP-complete problem.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04830</id>
    <link href="http://arxiv.org/abs/2002.04830" rel="alternate" type="text/html"/>
    <title>Positive Semidefinite Programming: Mixed, Parallel, and Width-Independent</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/j/Jambulapati:Arun.html">Arun Jambulapati</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lee:Yin_Tat.html">Yin Tat Lee</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Li:Jerry.html">Jerry Li</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Padmanabhan:Swati.html">Swati Padmanabhan</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/t/Tian:Kevin.html">Kevin Tian</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04830">PDF</a><br/><b>Abstract: </b>We give the first approximation algorithm for mixed packing and covering
semidefinite programs (SDPs) with polylogarithmic dependence on width. Mixed
packing and covering SDPs constitute a fundamental algorithmic primitive with
recent applications in combinatorial optimization, robust learning, and quantum
complexity. The current approximate solvers for positive semidefinite
programming can handle only pure packing instances, and technical hurdles
prevent their generalization to a wider class of positive instances. For a
given multiplicative accuracy of $\epsilon$, our algorithm takes
$O(\log^3(nd\rho) \cdot \epsilon^{-3})$ parallelizable iterations, where $n$,
$d$ are dimensions of the problem and $\rho$ is a width parameter of the
instance, generalizing or improving all previous parallel algorithms in the
positive linear and semidefinite programming literature. When specialized to
pure packing SDPs, our algorithm's iteration complexity is $O(\log^2 (nd) \cdot
\epsilon^{-2})$, a slight improvement and derandomization of the
state-of-the-art (Allen-Zhu et. al. '16, Peng et. al. '16, Wang et. al. '15).
For a wide variety of structured instances commonly found in applications, the
iterations of our algorithm run in nearly-linear time.
</p>
<p>In doing so, we give matrix analytic techniques for overcoming obstacles that
have stymied prior approaches to this open problem, as stated in past works
(Peng et. al. '16, Mahoney et. al. '16). Crucial to our analysis are a
simplification of existing algorithms for mixed positive linear programs,
achieved by removing an asymmetry caused by modifying covering constraints, and
a suite of matrix inequalities whose proofs are based on analyzing the Schur
complements of matrices in a higher dimension. We hope that both our algorithm
and techniques open the door to improved solvers for positive semidefinite
programming, as well as its applications.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04783</id>
    <link href="http://arxiv.org/abs/2002.04783" rel="alternate" type="text/html"/>
    <title>Revisiting Fixed Support Wasserstein Barycenter: Computational Hardness and Efficient Algorithms</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lin:Tianyi.html">Tianyi Lin</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Ho:Nhat.html">Nhat Ho</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/c/Chen:Xi.html">Xi Chen</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/c/Cuturi:Marco.html">Marco Cuturi</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/j/Jordan:Michael_I=.html">Michael I. Jordan</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04783">PDF</a><br/><b>Abstract: </b>We study the fixed-support Wasserstein barycenter problem (FS-WBP), which
consists in computing the Wasserstein barycenter of $m$ discrete probability
measures supported on a finite metric space of size $n$. We show first that the
constraint matrix arising from the linear programming (LP) representation of
the FS-WBP is totally unimodular when $m \geq 3$ and $n = 2$, but not totally
unimodular when $m \geq 3$ and $n \geq 3$. This result answers an open problem,
since it shows that the FS-WBP is not a minimum-cost flow problem and therefore
cannot be solved efficiently using linear programming. Building on this
negative result, we propose and analyze a simple and efficient variant of the
iterative Bregman projection (IBP) algorithm, currently the most widely adopted
algorithm to solve the FS-WBP. The algorithm is an accelerated IBP algorithm
which achieves the complexity bound of
$\widetilde{\mathcal{O}}(mn^{7/3}/\varepsilon)$. This bound is better than that
obtained for the standard IBP
algorithm---$\widetilde{\mathcal{O}}(mn^{2}/\varepsilon^2)$---in terms of
$\varepsilon$, and that of accelerated primal-dual gradient
algorithm---$\widetilde{\mathcal{O}}(mn^{5/2}/\varepsilon)$---in terms of $n$.
Empirical studies on simulated datasets demonstrate that the acceleration
promised by the theory is real in practice.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04778</id>
    <link href="http://arxiv.org/abs/2002.04778" rel="alternate" type="text/html"/>
    <title>Genomic Problems Involving Copy Number Profiles: Complexity and Algorithms</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lafond:Manuel.html">Manuel Lafond</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/z/Zhu:Binhai.html">Binhai Zhu</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/z/Zou:Peng.html">Peng Zou</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04778">PDF</a><br/><b>Abstract: </b>Recently, due to the genomic sequence analysis in several types of cancer,
the genomic data based on {\em copy number profiles} ({\em CNP} for short) are
getting more and more popular. A CNP is a vector where each component is a
non-negative integer representing the number of copies of a specific gene or
segment of interest.
</p>
<p>In this paper, we present two streams of results. The first is the negative
results on two open problems regarding the computational complexity of the
Minimum Copy Number Generation (MCNG) problem posed by Qingge et al. in 2018.
It was shown by Qingge et al. that the problem is NP-hard if the duplications
are tandem and they left the open question of whether the problem remains
NP-hard if arbitrary duplications are used. We answer this question
affirmatively in this paper; in fact, we prove that it is NP-hard to even
obtain a constant factor approximation. We also prove that the parameterized
version is W[1]-hard, answering another open question by Qingge et al.
</p>
<p>The other result is positive and is based on a new (and more general) problem
regarding CNP's. The \emph{Copy Number Profile Conforming (CNPC)} problem is
formally defined as follows: given two CNP's $C_1$ and $C_2$, compute two
strings $S_1$ and $S_2$ with $cnp(S_1)=C_1$ and $cnp(S_2)=C_2$ such that the
distance between $S_1$ and $S_2$, $d(S_1,S_2)$, is minimized. Here,
$d(S_1,S_2)$ is a very general term, which means it could be any genome
rearrangement distance (like reversal, transposition, and tandem duplication,
etc). We make the first step by showing that if $d(S_1,S_2)$ is measured by the
breakpoint distance then the problem is polynomially solvable.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04727</id>
    <link href="http://arxiv.org/abs/2002.04727" rel="alternate" type="text/html"/>
    <title>A simple certifying algorithm for 3-edge-connectivity</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/t/Tsin:Yung_H=.html">Yung H. Tsin</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04727">PDF</a><br/><b>Abstract: </b>A linear-time certifying algorithm for 3-edge-connectivity is presented.
Given an undirected graph G, if G is 3-edge-connected, the algorithm generates
a construction sequence as a positive certificate for G. Otherwise, the
algorithm decomposes G into its 3-edge-connected components and at the same
time generates a construction sequence for each connected component as well as
the bridges and a cactus representation of the cut-pairs in G. All of these are
done by making only one pass over G using an innovative graph contraction
technique. Moreover, the graph need not be 2-edge-connected.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04638</id>
    <link href="http://arxiv.org/abs/2002.04638" rel="alternate" type="text/html"/>
    <title>A polynomial time parallel algorithm for graph isomorphism using a quasipolynomial number of processors</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b>Duc Hung Pham, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Palem:Krishna_V=.html">Krishna V. Palem</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/r/Rao:M=_V=_Panduranga.html">M. V. Panduranga Rao</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04638">PDF</a><br/><b>Abstract: </b>The Graph Isomorphism (GI) problem is a theoretically interesting problem
because it has not been proven to be in P nor to be NP-complete. Babai made a
breakthrough in 2015 when announcing a quasipolynomial time algorithm for GI
problem. Babai's work gives the most theoretically efficient algorithm for GI,
as well as a strong evidence favoring the idea that class GI $\ne$ NP and thus
P $\ne$ NP. Based on Babai's algorithm, we prove that GI can further be solved
by a parallel algorithm that runs in polynomial time using a quasipolynomial
number of processors. We achieve that result by identifying the bottlenecks in
Babai's algorithms and parallelizing them. In particular, we prove that color
refinement can be computed in parallel logarithmic time using a polynomial
number of processors, and the $k$-dimensional WL refinement can be computed in
parallel polynomial time using a quasipolynomial number of processors. Our work
suggests that Graph Isomorphism and GI-complete problems can be computed
efficiently in a parallel computer, and provides insights on speeding up
parallel GI programs in practice.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-13T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04543</id>
    <link href="http://arxiv.org/abs/2002.04543" rel="alternate" type="text/html"/>
    <title>An Optimal Algorithm for Online Multiple Knapsack</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Bienkowski:Marcin.html">Marcin Bienkowski</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Pacut:Maciej.html">Maciej Pacut</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Piecuch:Krzysztof.html">Krzysztof Piecuch</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04543">PDF</a><br/><b>Abstract: </b>In the online multiple knapsack problem, an algorithm faces a stream of
items, and each item has to be either rejected or stored irrevocably in one of
$n$ bins (knapsacks) of equal size. The gain of an~algorithm is equal to the
sum of sizes of accepted items and the goal is to maximize the total gain.
</p>
<p>So far, for this natural problem, the best solution was the $0.5$-competitive
algorithm First Fit (the result holds for any $n \geq 2$). We present the first
algorithm that beats this ratio, achieving the competitive ratio of
$1/(1+\ln(2))-O(1/n) \approx 0.5906 - O(1/n)$.
</p>
<p>Our algorithm is deterministic and optimal up to lower-order terms, as the
upper bound of $1/(1+\ln(2))$ for randomized solutions was given previously by
Cygan et al. [TOCS 2016]. Furthermore, we show that the lower-order term is
inevitable for deterministic algorithms, by improving their upper bound to
$1/(1+\ln(2))-O(1/n)$.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-12T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04368</id>
    <link href="http://arxiv.org/abs/2002.04368" rel="alternate" type="text/html"/>
    <title>Hamiltonian Cycle Parameterized by Treedepth in Single Exponential Time and Polynomial Space</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/n/Nederlof:Jesper.html">Jesper Nederlof</a>, Michał Pilipczuk, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Swennenhuis:C=eacute=line_M=_F=.html">Céline M. F. Swennenhuis</a>, Karol Węgrzycki <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04368">PDF</a><br/><b>Abstract: </b>For many algorithmic problems on graphs of treewidth $t$, a standard dynamic
programming approach gives an algorithm with time and space complexity
$2^{\mathcal{O}(t)}\cdot n^{\mathcal{O}(1)}$. It turns out that when one
considers a more restrictive parameter treedepth, it is often the case that a
variation of this technique can be used to reduce the space complexity to
polynomial, while retaining time complexity of the form
$2^{\mathcal{O}(d)}\cdot n^{\mathcal{O}(1)}$, where $d$ is the treedepth. This
transfer of methodology is, however, far from being automatic. For instance,
for problems with connectivity constraints, standard dynamic programming
techniques give algorithms with time and space complexity $2^{\mathcal{O}(t\log
t)}\cdot n^{\mathcal{O}(1)}$ on graphs of treewidth $t$, but it is not clear
how to convert them into time-efficient polynomial space algorithms for graphs
of low treedepth.
</p>
<p>Cygan et al. (FOCS'11) introduced the Cut&amp;Count technique and showed that a
certain class of problems with connectivity constraints can be solved in time
and space complexity $2^{\mathcal{O}(t)}\cdot n^{\mathcal{O}(1)}$. Recently,
Hegerfeld and Kratsch (STACS'20) showed that, for some of those problems, the
Cut&amp;Count technique can be also applied in the setting of treedepth, and it
gives algorithms with running time $2^{\mathcal{O}(d)}\cdot n^{\mathcal{O}(1)}$
and polynomial space usage. However, a number of important problems eluded such
a treatment, with the most prominent examples being Hamiltonian Cycle and
Longest Path.
</p>
<p>In this paper we clarify the situation by showing that Hamiltonian Cycle,
Hamiltonian Path, Long Cycle, Long Path, and Min Cycle Cover all admit
$5^d\cdot n^{\mathcal{O}(1)}$-time and polynomial space algorithms on graphs of
treedepth $d$. The algorithms are randomized Monte Carlo with only false
negatives.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-12T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04338</id>
    <link href="http://arxiv.org/abs/2002.04338" rel="alternate" type="text/html"/>
    <title>Optimizing Item and Subgroup Configurations for Social-Aware VR Shopping</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Ko:Shao=Heng.html">Shao-Heng Ko</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lai:Hsu=Chao.html">Hsu-Chao Lai</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Shuai:Hong=Han.html">Hong-Han Shuai</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/y/Yang:De=Nian.html">De-Nian Yang</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/l/Lee:Wang=Chien.html">Wang-Chien Lee</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/y/Yu:Philip_S=.html">Philip S. Yu</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04338">PDF</a><br/><b>Abstract: </b>Shopping in VR malls has been regarded as a paradigm shift for E-commerce,
but most of the conventional VR shopping platforms are designed for a single
user. In this paper, we envisage a scenario of VR group shopping, which brings
major advantages over conventional group shopping in brick-and-mortar stores
and Web shopping: 1) configure flexible display of items and partitioning of
subgroups to address individual interests in the group, and 2) support social
interactions in the subgroups to boost sales. Accordingly, we formulate the
Social-aware VR Group-Item Configuration (SVGIC) problem to configure a set of
displayed items for flexibly partitioned subgroups of users in VR group
shopping. We prove SVGIC is NP-hard to approximate within $\frac{32}{31} -
\epsilon$. We design an approximation algorithm based on the idea of Co-display
Subgroup Formation (CSF) to configure proper items for display to different
subgroups of friends. Experimental results on real VR datasets and a user study
with hTC VIVE manifest that our algorithms outperform baseline approaches by at
least 30.1% of solution quality.
</p></div>
    </summary>
    <updated>2020-02-13T00:21:08Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-12T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04149</id>
    <link href="http://arxiv.org/abs/2002.04149" rel="alternate" type="text/html"/>
    <title>Maximizing Products of Linear Forms, and The Permanent of Positive Semidefinite Matrices</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/y/Yuan:Chenyang.html">Chenyang Yuan</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Parrilo:Pablo_A=.html">Pablo A. Parrilo</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04149">PDF</a><br/><b>Abstract: </b>We study the convex relaxation of a polynomial optimization problem,
maximizing a product of linear forms over the complex sphere. We show that this
convex program is also a relaxation of the permanent of Hermitian positive
semidefinite (HPSD) matrices. By analyzing a constructive randomized rounding
algorithm, we obtain an improved multiplicative approximation factor to the
permanent of HPSD matrices. We also propose an analog of Van der Waerden's
conjecture for HPSD matrices, where the polynomial optimization problem is
interpreted as a relaxation of the permanent.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-12T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04063</id>
    <link href="http://arxiv.org/abs/2002.04063" rel="alternate" type="text/html"/>
    <title>On the Unreasonable Effectiveness of the Greedy Algorithm: Greedy Adapts to Sharpness</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/t/Torrico:Alfredo.html">Alfredo Torrico</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Singh:Mohit.html">Mohit Singh</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Pokutta:Sebastian.html">Sebastian Pokutta</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04063">PDF</a><br/><b>Abstract: </b>Submodular maximization has been widely studied over the past decades, mostly
because of its numerous applications in real-world problems. It is well known
that the standard greedy algorithm guarantees a worst-case approximation factor
of 1-1/e when maximizing a monotone submodular function under a cardinality
constraint. However, empirical studies show that its performance is
substantially better in practice. This raises a natural question of explaining
this improved performance of the greedy algorithm. In this work, we define
sharpness for submodular functions as a candidate explanation for this
phenomenon. The sharpness criterion is inspired by the concept of strong
convexity in convex optimization. We show that the greedy algorithm provably
performs better as the sharpness of the submodular function increases. This
improvement ties in closely with the faster convergence rates of first order
methods for sharp functions in convex optimization. Finally, we perform a
computational study to empirically support our theoretical results and show
that sharpness explains the greedy performance better than other justifications
in the literature.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-12T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04048</id>
    <link href="http://arxiv.org/abs/2002.04048" rel="alternate" type="text/html"/>
    <title>$2$-node-connectivity network design</title>
    <feedworld_mtime>1581552000</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/n/Nutov:Zeev.html">Zeev Nutov</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04048">PDF</a><br/><b>Abstract: </b>We consider network design problems in which we are given a graph $G=(V,E)$
with edge costs, and seek a min-cost/size $2$-node-connected subgraph
$G'=(V',E')$ that satisfies a prescribed property. In the Block-Tree
Augmentation problem the goal is to augment a tree $T$ by a min-size edge set
$F \subseteq E$ such that $G'=T \cup F$ is $2$-node-connected. We break the
natural ratio of $2$ for this problem and show that it admits approximation
ratio $1.91$. This result extends to the related Crossing Family Augmentation
problem. In the $2$-Connected Dominating Set problem $G'$ should dominate $V$.
We give the first non-trivial approximation algorithm for this problem, with
expected ratio $\tilde{O}(\log^4 |V|)$. In the $2$-Connected Quota Subgraph
problem we are given node profits $p(v)$ and $G'$ should have profit at least a
given quota $Q$. We show expected ratio $\tilde{O}(\log^2|V|)$, almost matching
the best known ratio $O(\log^2|V|)$.
</p>
<p>Our algorithms are very simple, and they combine three main ingredients. 1. A
probabilistic spanning tree embedding with distortion $\tilde{O}(\log |V|)$
results in a variant of the Block-Tree Augmentation problem. 2. An
approximation ratio preserving reduction of Block-Tree Augmentation variants to
Node Weighted Steiner Tree problems. 3. Using existing approximation algorithms
for variants of the Node Weighted Steiner Tree problem.
</p></div>
    </summary>
    <updated>2020-02-13T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Data Structures and Algorithms"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.DS" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Data Structures and Algorithms (cs.DS) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.DS updates on arXiv.org</title>
      <updated>2020-02-12T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>https://eccc.weizmann.ac.il/report/2020/010</id>
    <link href="https://eccc.weizmann.ac.il/report/2020/010" rel="alternate" type="text/html"/>
    <title>TR20-010 |  Strong Average-Case Circuit Lower Bounds from Non-trivial Derandomization | 

	Lijie Chen, 

	Hanlin Ren</title>
    <summary>We prove that for all constants a, NQP = NTIME[n^{polylog(n)}] cannot be (1/2 + 2^{-log^a n})-approximated by 2^{log^a n}-size ACC^0 of THR circuits (ACC^0 circuits with a bottom layer of THR gates). Previously, it was even open whether E^NP can be (1/2+1/sqrt{n})-approximated by AC^0[2] circuits. As a straightforward application, we obtain an infinitely often (NE cap coNE)_{/1}-computable pseudorandom generator for poly-size ACC^0 circuits with seed length 2^{log^{eps} n}, for all eps &gt; 0.
    
    More generally, we establish a connection showing that, for a typical circuit class C, non-trivial nondeterministic algorithms estimating the acceptance probability of a given S-size C circuit with an additive error 1/S (we call it a CAPP algorithm) imply strong (1/2 + 1/n^omega(1)) average-case lower bounds for nondeterministic time classes against C circuits. Note that the existence of such (deterministic) algorithms is much weaker than the widely believed conjecture PromiseBPP = PromiseP.
    
    We also apply our results to several sub-classes of TC^0 circuits. First, we show that for all k, NP cannot be (1/2 + n^{-k})-approximated by n^k-size Sum of THR circuits (exact R-linear combination of threshold gates), improving the corresponding worst-case result in [Williams, CCC 2018]. Second, we establish strong average-case lower bounds and build (NE cap coNE)_{/1}-computable PRGs for Sum of PTF circuits, for various regimes of degrees. Third, we show that non-trivial CAPP algorithms for MAJ of MAJ indeed already imply worst-case lower bounds for TC^0_3 (MAJ of MAJ of MAJ). Since exponential lower bounds for MAJ of MAJ are already known, this suggests TC^0_3 lower bounds are probably within reach. 
    
    Our new results build on a line of recent works, including [Murray and Williams, STOC 2018], [Chen and Williams, CCC 2019] and [Chen, FOCS 2019]. In particular, it strengthens the corresponding (1/2 + 1/polylog(n))-inapproximability average-case lower bounds in [Chen, FOCS 2019].
    
    The two important technical ingredients are techniques from Cryptography in NC^0 [Applebaum et al., SICOMP 2006], and Probabilistic Checkable Proofs of Proximity with NC^1-computable proofs.</summary>
    <updated>2020-02-12T16:46:17Z</updated>
    <published>2020-02-12T16:46:17Z</published>
    <source>
      <id>https://eccc.weizmann.ac.il/</id>
      <author>
        <name>ECCC papers</name>
      </author>
      <link href="https://eccc.weizmann.ac.il/" rel="alternate" type="text/html"/>
      <link href="https://example.com/feeds/reports/" rel="self" type="application/atom+xml"/>
      <subtitle>Latest Reports published at https://eccc.weizmann.ac.il</subtitle>
      <title>ECCC - Reports</title>
      <updated>2020-02-13T12:20:26Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://theorydish.blog/?p=1555</id>
    <link href="https://theorydish.blog/2020/02/11/approx-random-2020/" rel="alternate" type="text/html"/>
    <title>APPROX-RANDOM 2020</title>
    <summary>The CFPs for APPROX 2020 and RANDOM 2020 are out. The conference will be held August 17-19, 2020 at the University of Washington in Seattle. Submissions: April 24, 2020.    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>The CFPs for <a href="https://approxconference.wordpress.com/approx-2020/">APPROX 2020</a> and <a href="https://randomconference.com/random-2020-home/">RANDOM 2020</a> are out. The conference will be held August 17-19, 2020 at the University of Washington in Seattle. <strong>Submissions:</strong> April 24, 2020.</p>
<p> </p>
<p> </p></div>
    </content>
    <updated>2020-02-12T06:21:12Z</updated>
    <published>2020-02-12T06:21:12Z</published>
    <category term="Uncategorized"/>
    <author>
      <name>Omer Reingold</name>
    </author>
    <source>
      <id>https://theorydish.blog</id>
      <logo>https://theorydish.files.wordpress.com/2017/03/cropped-nightdish1.jpg?w=32</logo>
      <link href="https://theorydish.blog/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://theorydish.blog" rel="alternate" type="text/html"/>
      <link href="https://theorydish.blog/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://theorydish.blog/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>Stanford's CS Theory Research Blog</subtitle>
      <title>Theory Dish</title>
      <updated>2020-02-13T12:21:25Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04590</id>
    <link href="http://arxiv.org/abs/2002.04590" rel="alternate" type="text/html"/>
    <title>Local WL Invariance and Hidden Shades of Regularity</title>
    <feedworld_mtime>1581465600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/f/Fuhlbr=uuml=ck:Frank.html">Frank Fuhlbrück</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/K=ouml=bler:Johannes.html">Johannes Köbler</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/v/Verbitsky:Oleg.html">Oleg Verbitsky</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04590">PDF</a><br/><b>Abstract: </b>The $k$-dimensional Weisfeiler-Leman algorithm ($k$-WL) is a powerful tool
for testing isomorphism of two given graphs. We aim at investigating the
ability of $k$-WL to capture properties of vertices (or small sets of vertices)
in a single input graph $G$. In general, $k$-WL computes a canonical coloring
of $k$-tuples of vertices of $G$, which determines a canonical coloring of
$s$-tuples for each $s$ between 1 and $k$. We say that a property (or a
numerical parameter) of $s$-tuples is $k$-invariant if it is determined by the
tuple color. Our main result establishes $k$-invariance of the parameters
counting the number of extensions of an $s$-tuple of vertices to a given
subgraph pattern $F$. We state a sufficient condition for $k$-invariance in
terms of the treewidth of $F$ and its homomorphic images, using suitable
variants of these concepts for graphs with $s$ designated roots. As an
application, we observe some non-obvious regularity properties of strongly
regular graphs: For example, if $G$ is strongly regular, then the number of
paths of length 6 between vertices $x$ and $y$ in $G$ depends only on whether
or not $x$ and $y$ are adjacent (and the length 6 is here optimal). Despite the
fact that $k$-WL indistinguishability of vertex tuples implies high degree of
regularity, we prove, on the negative side, that no fixed dimension $k$
suffices for $k$-WL to recognize global symmetry of a graph. Specifically, for
every $k$, there is a graph $G$ whose vertex set is colored by $k$-WL uniformly
while $G$ is not vertex-transitive.
</p></div>
    </summary>
    <updated>2020-02-12T00:00:00Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2020-02-12T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>http://arxiv.org/abs/2002.04244</id>
    <link href="http://arxiv.org/abs/2002.04244" rel="alternate" type="text/html"/>
    <title>Rapid Top-Down Synthesis of Large-Scale IoT Networks</title>
    <feedworld_mtime>1581465600</feedworld_mtime>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><b>Authors: </b><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Ghosh:Pradipta.html">Pradipta Ghosh</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/b/Bunton:Jonathan.html">Jonathan Bunton</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/p/Pylorof:Dimitrios.html">Dimitrios Pylorof</a>, Marcos Vieira, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/c/Chan:Kevin.html">Kevin Chan</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Govindan:Ramesh.html">Ramesh Govindan</a>, Gaurav Sukhatme, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/t/Tabuada:Paulo.html">Paulo Tabuada</a>, <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/v/Verma:Gunjan.html">Gunjan Verma</a> <br/><b>Download:</b> <a href="http://arxiv.org/pdf/2002.04244">PDF</a><br/><b>Abstract: </b>Advances in optimization and constraint satisfaction techniques, together
with the availability of elastic computing resources, have spurred interest in
large-scale network verification and synthesis. Motivated by this, we consider
the top-down synthesis of ad-hoc IoT networks for disaster response and search
and rescue operations. This synthesis problem must satisfy complex and
competing constraints: sensor coverage, line-of-sight visibility, and network
connectivity. The central challenge in our synthesis problem is quickly scaling
to large regions while producing cost-effective solutions. We explore two
qualitatively different representations of the synthesis problems
satisfiability modulo convex optimization (SMC), and mixed-integer linear
programming (MILP). The former is more expressive, for our problem, than the
latter, but is less well-suited for solving optimization problems like ours. We
show how to express our network synthesis in these frameworks, and, to scale to
problem sizes beyond what these frameworks are capable of, develop a
hierarchical synthesis technique that independently synthesizes networks in
sub-regions of the deployment area, then combines these. We find that, while
MILP outperforms SMC in some settings for smaller problem sizes, the fact that
SMC's expressivity matches our problem ensures that it uniformly generates
better quality solutions at larger problem sizes.
</p></div>
    </summary>
    <updated>2020-02-12T23:21:19Z</updated>
    <author>
      <name/>
    </author>
    <source>
      <id>http://arxiv.org/</id>
      <category term="Computer Science -- Computational Complexity"/>
      <link href="http://arxiv.org/" rel="alternate" type="text/html"/>
      <link href="http://export.arxiv.org/rss/cs.CC" rel="self" type="application/rdf+xml"/>
      <subtitle>Computer Science -- Computational Complexity (cs.CC) updates on the arXiv.org e-print archive</subtitle>
      <title>cs.CC updates on arXiv.org</title>
      <updated>2020-02-12T01:30:00Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://rjlipton.wordpress.com/?p=16664</id>
    <link href="https://rjlipton.wordpress.com/2020/02/11/using-negative-nodes-to-count/" rel="alternate" type="text/html"/>
    <title>Using Negative Nodes to Count</title>
    <summary>A deeper basis for generalized Tutte-Grothendieck invariants Via Psychology Today article Alexander Grothendieck peppered algebraic geometry with nilpotent elements. He augmented spaces with elements such that for some power , . Despite debates over whether such ephemeral entities could be “natural,” they make many calculations nicer. Today we ask whether some additions to graph theory […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><font color="#0044cc"><br/>
<em>A deeper basis for generalized Tutte-Grothendieck invariants</em><br/>
<font color="#000000"/></font></p><font color="#0044cc"><font color="#000000">
<table class="image alignright">
<tbody>
<tr>
<td>
<a href="https://rjlipton.wordpress.com/2020/02/11/using-negative-nodes-to-count/grothendieckstructureobject/" rel="attachment wp-att-16674"><img alt="" class="alignright wp-image-16674" height="180" src="https://rjlipton.files.wordpress.com/2020/02/grothendieckstructureobject.png?w=150&amp;h=180" width="150"/></a>
</td>
</tr>
<tr>
<td class="caption alignright"><font size="-2">Via <i>Psychology Today</i> <a href="https://www.psychologytoday.com/us/articles/201707/the-mad-genius-mystery">article</a></font></td>
</tr>
</tbody>
</table>
<p>
Alexander Grothendieck peppered algebraic geometry with nilpotent elements. He augmented spaces with elements <img alt="{x}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bx%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{x}"/> such that for some power <img alt="{a}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Ba%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{a}"/>, <img alt="{x^a = 0}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bx%5Ea+%3D+0%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{x^a = 0}"/>. Despite debates over whether such ephemeral entities could be “natural,” they make many calculations nicer.</p>
<p>
Today we ask whether some additions to graph theory may have similar effect.</p>
<p>
Adding extra elements to avoid special cases is an old idea that happens throughout mathematics. Gerolamo Cardano made perhaps the first mention of <img alt="{i}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bi%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{i}"/> in his work on solving cubic equations in 1545, but argument swirled on whether <img alt="{i}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bi%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{i}"/> is a true mathematical object. The term “imaginary number” was coined by René Descartes in 1637 to sneer at it, and <img alt="{i}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bi%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{i}"/> took over a century more to gain wide acceptance.</p>
<p>
Regarding nilpotents, a commenter in a MathOverflow <a href="https://mathoverflow.net/questions/55244/why-nilpotent-elements-must-be-allowed-in-modern-algebraic-geometry">item</a> nine years ago expressed the motivation in terms analogous to our purpose:</p>
<blockquote><p><b> </b> <em> Grothendieck introduced nilpotents for many reasons … to get correct counting in degenerate situations, it is typically necessary to allow nilpotents; they are also the bedrock of [other] ideas in algebraic geometry. </em>
</p></blockquote>
<p/><p>
His comment went on to describe a situation where nilpotents allow one to <em>reduce</em> the task of checking certain properties to well-behaved cases. he continued:</p>
<blockquote><p><b> </b> <em> This is a powerful method, which … comes up in lots of places, e.g. in establishing basic properties of abelian schemes, by reducing to the abelian variety case. </em>
</p></blockquote>
<p/><p>
Other comments show how nilpotents make counting come out right. An early-2015 <a href="https://www.nature.com/articles/517272a">obituary</a> by the algebraic geometers David Mumford and John Tate gave the motivation of modeling small <img alt="{\epsilon}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cepsilon%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\epsilon}"/> under assumptions like <img alt="{\epsilon^2 = 0}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cepsilon%5E2+%3D+0%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\epsilon^2 = 0}"/>, and my own memorial <a href="https://rjlipton.wordpress.com/2014/11/16/alexander-grothendieck-1928-2014/">post</a> gave other aspects of them. We wonder whether something roughly analogous can make a counting tool in combinatorics—one already co-named for Grothendieck—more acute for purposes such as evaluating quantum circuits.</p>
<p>
</p><p/><h2> Duality and Isolated Nodes </h2><p/>
<p/><p>
In our previous <a href="https://rjlipton.wordpress.com/2020/02/01/subliminal-graph-duals/">post</a> we discussed how the 2-polymatroid dual <img alt="{G^*}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%5E%2A%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G^*}"/> of a graph <img alt="{G = (V,E)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%3D+%28V%2CE%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G = (V,E)}"/> is an isomorphism invariant so that <img alt="{(G^{*})^* = G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28G%5E%7B%2A%7D%29%5E%2A+%3D+G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(G^{*})^* = G}"/>. This requires shifting attention to the structure <img alt="{(E,r_G)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28E%2Cr_G%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(E,r_G)}"/> where the <em>rank function</em> <img alt="{r_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_G}"/> is defined for all subsets <img alt="{A}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BA%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{A}"/> of <img alt="{E}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BE%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{E}"/> by </p>
<p align="center"><img alt="\displaystyle  r_G(A) = ||\{u \in V: (\exists v \in V)(u,v) \in A\}||. " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++r_G%28A%29+%3D+%7C%7C%5C%7Bu+%5Cin+V%3A+%28%5Cexists+v+%5Cin+V%29%28u%2Cv%29+%5Cin+A%5C%7D%7C%7C.+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  r_G(A) = ||\{u \in V: (\exists v \in V)(u,v) \in A\}||. "/></p>
<p>Here <img alt="{v = u}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bv+%3D+u%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{v = u}"/> is allowed so <img alt="{A}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BA%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{A}"/> can have loops, and the definition if coherent even if <img alt="{A}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BA%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{A}"/> is a multiset—the ambiguity of which of multiple edges is “<img alt="{(u,v)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28u%2Cv%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(u,v)}"/>” does not matter. The definition does exclude <em>circles</em>, which touch no vertex but can still belong to <img alt="{A}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BA%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{A}"/>. That is OK because circles contribute <img alt="{0}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B0%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{0}"/> to the rank in all cases. </p>
<p>
There is, however, an asterisk: the structure <img alt="{(E,r_G)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28E%2Cr_G%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(E,r_G)}"/> ignores any isolated nodes <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> may have. Isolated nodes do not contribute anything to any subset of <img alt="{E}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BE%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{E}"/>. Thus we really have <img alt="{(G^{*})^* = G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28G%5E%7B%2A%7D%29%5E%2A+%3D+G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(G^{*})^* = G}"/> <em>iff <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> has no isolated nodes</em>. </p>
<p>
Our last post showed examples where deleting an edge in <img alt="{G^*}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%5E%2A%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G^*}"/> corresponded to “exploding” it in <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/>. Let us flip that around so that the deletion occurs in <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/>, the explosion in <img alt="{G^*}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%5E%2A%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G^*}"/>. Here is the example of the “lollipop” graph:</p>
<p><a href="https://rjlipton.wordpress.com/2020/02/11/using-negative-nodes-to-count/lollipopnegativeisol/" rel="attachment wp-att-16670"><img alt="" class="aligncenter wp-image-16670" height="153" src="https://rjlipton.files.wordpress.com/2020/02/lollipopnegativeisol.jpg?w=360&amp;h=153" width="360"/></a></p>
<p>
The operations do not quite commute because the deletion of the edge <img alt="{b}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bb%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{b}"/> leaves an isolated node, whereas the explosion of <img alt="{b}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bb%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{b}"/> in the dual—as it was defined—does not. What should go in place of the ‘(?)’? We contend that the answer is: <em>a negative isolated node</em>. We denote it by <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/>, whereas an ordinary isolated node is <img alt="{\bullet}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbullet%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bullet}"/>.</p>
<p>
All uses of <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/> that we need can come from one extra clause in the definition of explosion given <a href="https://rjlipton.wordpress.com/2020/02/01/subliminal-graph-duals/">there</a> and in the major reference of our <a href="https://rjlipton.wordpress.com/2019/06/17/contraction-and-explosion/">post</a> on explosion last summer:</p>
<blockquote><p><b> </b> <em> Exploding a loop, as opposed to a regular edge, also introduces one <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{\ominus}"/>. Exploding a circle leaves two: <img alt="{\ominus~\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7E%5Cominus%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{\ominus~\ominus}"/>. </em>
</p></blockquote>
<p>
</p><p/><h2> A Simple Recurrence and Duality </h2><p/>
<p/><p>
At the end of a recent <a href="https://rjlipton.wordpress.com/2020/02/01/subliminal-graph-duals/">post</a> we noted that for the planar dual or other surface dual <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/> of a graph <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/>, deleting an edge in <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> <em>contracts</em> the corresponding edge of <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/>. This lends mathematical power to the <em>deletion-contraction</em> recurrence by which William Tutte defined his polynomial <img alt="{T_G(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BT_G%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{T_G(x,y)}"/>. We denote deletion by <img alt="{G \setminus e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%5Csetminus+e%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G \setminus e}"/>, contraction by <img alt="{G/e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%2Fe%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G/e}"/>, and explosion by <img alt="{G \backslash\!\backslash e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%5Cbackslash%5C%21%5Cbackslash+e%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G \backslash\!\backslash e}"/>.</p>
<p>
What we call “explosion” is the effect on graphs of the notion of <em>contraction</em> that applies to matroids, in particular graphic 2-polymatroids (G2PMs). James Oxley and Geoff Whittle, in their 1993 <a href="http://homepages.mcs.vuw.ac.nz/~whittle/pubs/Tutte_invariants_of_2-polymatroids.pdf">paper</a> which we featured in a previous <a href="https://rjlipton.wordpress.com/2019/08/26/a-matroid-quantum-connection/">post</a>, define a <b>generalized Tutte-Grothendieck invariant</b> (GTGI) to be any algebraic quantity <img alt="{\phi_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cphi_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\phi_G}"/> that obeys a recurrence with deletion and matroid contraction (which we call explosion) instead:</p>
<ul>
<li>
If <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> is a disjoint union of <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/> and <img alt="{G''}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G''}"/>, then <img alt="{\phi(G) = \phi({G'})\phi({G''})}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cphi%28G%29+%3D+%5Cphi%28%7BG%27%7D%29%5Cphi%28%7BG%27%27%7D%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\phi(G) = \phi({G'})\phi({G''})}"/>; <p/>
</li><li>
For any edge or loop <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/> in <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/>, <a name="recurse"><p/>
<p align="center"><img alt="\displaystyle  \phi(G) = \alpha\phi({G \setminus e}) + \beta\phi({G \backslash\!\backslash e}). \ \ \ \ \ (1)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Cphi%28G%29+%3D+%5Calpha%5Cphi%28%7BG+%5Csetminus+e%7D%29+%2B+%5Cbeta%5Cphi%28%7BG+%5Cbackslash%5C%21%5Cbackslash+e%7D%29.+%5C+%5C+%5C+%5C+%5C+%281%29&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  \phi(G) = \alpha\phi({G \setminus e}) + \beta\phi({G \backslash\!\backslash e}). \ \ \ \ \ (1)"/></p>
</a><p><a name="recurse"/>
</p></li></ul>
<p>
Their definition does not specify base cases. All previous papers we’ve found have used one-edge graphs as their base cases. Our first benefit of negative isolated nodes is that we can define a basis for <em>zero</em> edges in a way that reveals even more cleanly that GTGIs <img alt="{\phi}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cphi%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\phi}"/> are basically polynomials. Define: </p>
<p align="center"><img alt="\displaystyle  \phi({\emptyset}) = 1,\quad \phi(\bullet) = x,\quad \phi({\ominus}) = y. " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Cphi%28%7B%5Cemptyset%7D%29+%3D+1%2C%5Cquad+%5Cphi%28%5Cbullet%29+%3D+x%2C%5Cquad+%5Cphi%28%7B%5Cominus%7D%29+%3D+y.+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  \phi({\emptyset}) = 1,\quad \phi(\bullet) = x,\quad \phi({\ominus}) = y. "/></p>
<p>Here <img alt="{x}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bx%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{x}"/> and <img alt="{y}" class="latex" src="https://s0.wp.com/latex.php?latex=%7By%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{y}"/> can be arbitrary objects, not just variables, but the point is that we can always treat them as variables. Thus all of these rules define a polynomial which we call <img alt="{R_{G,\alpha,\beta}(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7BG%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{G,\alpha,\beta}(x,y)}"/>. It is not immediately clear that this is well defined—i.e., independent of the order in which edges <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/> are chosen.</p>
<p>
Now we look at the one-edge cases, which are the circle <img alt="{\bigcirc}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbigcirc%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bigcirc}"/>, the loop <img alt="{G_1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG_1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G_1}"/>, and the graph <img alt="{G_2}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG_2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G_2}"/> of one regular edge. We obtain: </p>
<p align="center"><img alt="\displaystyle  \begin{array}{rcl}  R_{\bigcirc,\alpha,\beta}(x,y) &amp;=&amp; \alpha + \beta y^2;\\ R_{G_1,\alpha,\beta}(x,y) &amp;=&amp; \alpha x + \beta y;\\ R_{G_2,\alpha,\beta}(x,y) &amp;=&amp; \alpha x^2 + \beta. \end{array} " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Cbegin%7Barray%7D%7Brcl%7D++R_%7B%5Cbigcirc%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%26%3D%26+%5Calpha+%2B+%5Cbeta+y%5E2%3B%5C%5C+R_%7BG_1%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%26%3D%26+%5Calpha+x+%2B+%5Cbeta+y%3B%5C%5C+R_%7BG_2%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%26%3D%26+%5Calpha+x%5E2+%2B+%5Cbeta.+%5Cend%7Barray%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  \begin{array}{rcl}  R_{\bigcirc,\alpha,\beta}(x,y) &amp;=&amp; \alpha + \beta y^2;\\ R_{G_1,\alpha,\beta}(x,y) &amp;=&amp; \alpha x + \beta y;\\ R_{G_2,\alpha,\beta}(x,y) &amp;=&amp; \alpha x^2 + \beta. \end{array} "/></p>
<p>This is pleasingly symmetric, which bodes well for effective use of duality. Note that switching <img alt="{x}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bx%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{x}"/> with <img alt="{y}" class="latex" src="https://s0.wp.com/latex.php?latex=%7By%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{y}"/> and <img alt="{\alpha}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Calpha%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\alpha}"/> with <img alt="{\beta}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbeta%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\beta}"/> preserves <img alt="{R_{G_1,\alpha,\beta}(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7BG_1%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{G_1,\alpha,\beta}(x,y)}"/> but interchanges <img alt="{R_{\bigcirc,\alpha,\beta}(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7B%5Cbigcirc%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{\bigcirc,\alpha,\beta}(x,y)}"/> with <img alt="{R_{G_2,\alpha,\beta}(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7BG_2%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{G_2,\alpha,\beta}(x,y)}"/>. Recall from the previous <a href="https://rjlipton.wordpress.com/2020/02/01/subliminal-graph-duals/">post</a> that <img alt="{G_1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG_1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G_1}"/> is self-dual while <img alt="{G_2}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG_2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G_2}"/> and <img alt="{\bigcirc}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbigcirc%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bigcirc}"/> are dual to each other. This is no accident:</p>
<blockquote><p><b>Theorem 1</b> <em> For any generalized Tutte-Grothendieck invariant <img alt="{R_{G,\alpha,\beta}(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7BG%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{R_{G,\alpha,\beta}(x,y)}"/> and (graphical) 2-polymatroid <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{G}"/>, </em></p><em>
<p align="center"><img alt="\displaystyle  R_{G^*,\alpha,\beta}(x,y) = R_{G,\beta,\alpha}(y,x). " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++R_%7BG%5E%2A%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%3D+R_%7BG%2C%5Cbeta%2C%5Calpha%7D%28y%2Cx%29.+&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="\displaystyle  R_{G^*,\alpha,\beta}(x,y) = R_{G,\beta,\alpha}(y,x). "/></p>
</em><p><em/>
</p></blockquote>
<p/><p>
The proof is immediate by the base cases <img alt="{\bullet}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbullet%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bullet}"/> and <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/>, the form of the recursion (<a href="https://rjlipton.wordpress.com/feed/#recurse">1</a>), and the duality of deletion and explosion via <img alt="{G \backslash\!\backslash e = (G^* \setminus e)^*}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%5Cbackslash%5C%21%5Cbackslash+e+%3D+%28G%5E%2A+%5Csetminus+e%29%5E%2A%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G \backslash\!\backslash e = (G^* \setminus e)^*}"/>.</p>
<p>
Abbreviate <img alt="{R_{G,1,1}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7BG%2C1%2C1%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{G,1,1}}"/> for the case <img alt="{\alpha,\beta = 1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Calpha%2C%5Cbeta+%3D+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\alpha,\beta = 1}"/> to just <img alt="{R_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_G}"/>. We will connect <img alt="{R_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_G}"/> to the polynomial <img alt="{S_G(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BS_G%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{S_G(x,y)}"/> introduced by Oxley and Whittle as discussed in our <a href="https://rjlipton.wordpress.com/2019/08/26/a-matroid-quantum-connection/">post</a>. They use the term “recipe theorem” for the general idea that all GTGIs are evaluations of the single <img alt="{\alpha,\beta = 1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Calpha%2C%5Cbeta+%3D+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\alpha,\beta = 1}"/> at different points, ascribing it to work by Oxley with Dominic Welsh, who was my own doctoral advisor a few years after Oxley. </p>
<p>
</p><p/><h2> Re-Basing the Recipe Theorem </h2><p/>
<p/><p>
Henceforth let <img alt="{G = (V,E)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%3D+%28V%2CE%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G = (V,E)}"/> stand for a graph augmented with both circles and negative isolated nodes. The associated G2PM is <img alt="{(E,r)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28E%2Cr%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(E,r)}"/> where <img alt="{r = r_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br+%3D+r_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r = r_G}"/> is the rank function as above. Let <img alt="{n_{\ominus}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn_%7B%5Cominus%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n_{\ominus}}"/> stand for the number of negative isolated nodes and <img alt="{n}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n}"/> for the count of nodes in which each <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/> counts <img alt="{-1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B-1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{-1}"/>. That is, <img alt="{n = |V| - 2n_{\ominus}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn+%3D+%7CV%7C+-+2n_%7B%5Cominus%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n = |V| - 2n_{\ominus}}"/>. </p>
<blockquote><p><b>Theorem 2 (Recipe Theorem)</b> <em> For all <img alt="{G,\alpha,\beta}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%2C%5Calpha%2C%5Cbeta%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{G,\alpha,\beta}"/>, with <img alt="{\rho = \sqrt{\frac{\beta}{\alpha}}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Crho+%3D+%5Csqrt%7B%5Cfrac%7B%5Cbeta%7D%7B%5Calpha%7D%7D%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{\rho = \sqrt{\frac{\beta}{\alpha}}}"/>, <a name="recipe"/></em></p><em><a name="recipe">
<p align="center"><img alt="\displaystyle  R_{G,\alpha,\beta}(x,y) = \alpha^{|E|}\rho^n R_G(\frac{x}{\rho}, \rho y). \ \ \ \ \ (2)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++R_%7BG%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%3D+%5Calpha%5E%7B%7CE%7C%7D%5Crho%5En+R_G%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29.+%5C+%5C+%5C+%5C+%5C+%282%29&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="\displaystyle  R_{G,\alpha,\beta}(x,y) = \alpha^{|E|}\rho^n R_G(\frac{x}{\rho}, \rho y). \ \ \ \ \ (2)"/></p>
</a></em><p><em><a name="recipe"/> </em>
</p></blockquote>
<p/><p>
<em>Proof:</em>  For the base case of a completely empty graph, we have <img alt="{|E| = 0}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%7CE%7C+%3D+0%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{|E| = 0}"/> and <img alt="{n = 0}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn+%3D+0%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n = 0}"/>, so <img alt="{R_{\emptyset,\alpha,\beta}(x,y) = R_{\emptyset}(\frac{x}{\rho}, \rho y) = 1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7B%5Cemptyset%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%3D+R_%7B%5Cemptyset%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29+%3D+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{\emptyset,\alpha,\beta}(x,y) = R_{\emptyset}(\frac{x}{\rho}, \rho y) = 1}"/>. For the base case of a single isolated node, <img alt="{|E| = 0}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%7CE%7C+%3D+0%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{|E| = 0}"/> but <img alt="{n = 1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn+%3D+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n = 1}"/>, so we get </p>
<p align="center"><img alt="\displaystyle  \rho R_{\bullet}(\frac{x}{\rho}, \rho y) = \rho\frac{x}{\rho} = x, " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Crho+R_%7B%5Cbullet%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29+%3D+%5Crho%5Cfrac%7Bx%7D%7B%5Crho%7D+%3D+x%2C+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  \rho R_{\bullet}(\frac{x}{\rho}, \rho y) = \rho\frac{x}{\rho} = x, "/></p>
<p>as required. For <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/> we have <img alt="{n = -1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn+%3D+-1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n = -1}"/> so we get </p>
<p align="center"><img alt="\displaystyle  \rho^{-1} R_{\ominus}(\frac{x}{\rho}, \rho y) =\rho^{-1} \rho y = y, " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Crho%5E%7B-1%7D+R_%7B%5Cominus%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29+%3D%5Crho%5E%7B-1%7D+%5Crho+y+%3D+y%2C+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  \rho^{-1} R_{\ominus}(\frac{x}{\rho}, \rho y) =\rho^{-1} \rho y = y, "/></p>
<p>again as required of <img alt="{R_{\ominus,\alpha,\beta}(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7B%5Cominus%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{\ominus,\alpha,\beta}(x,y)}"/>. If <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> is a disjoint union of <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/> and <img alt="{G''}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G''}"/>, multiplicativity goes through because <img alt="{n = n' + n''}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn+%3D+n%27+%2B+n%27%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n = n' + n''}"/> and <img alt="{|E| = |E'| + |E''|}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%7CE%7C+%3D+%7CE%27%7C+%2B+%7CE%27%27%7C%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{|E| = |E'| + |E''|}"/> for the respective components. </p>
<p>
Now let <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/> be any edge in <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/>. Note that in <img alt="{G' = G \backslash\!\backslash r}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27+%3D+G+%5Cbackslash%5C%21%5Cbackslash+r%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G' = G \backslash\!\backslash r}"/>, the new <img alt="{n'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n'}"/> equals <img alt="{n-2}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn-2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n-2}"/> whether <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/> is a regular edge or a loop, the latter owing to introducing one <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/>. Supposing by induction that (<a href="https://rjlipton.wordpress.com/feed/#recipe">2</a>) is valid for <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> and for <img alt="{G \setminus e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%5Csetminus+e%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G \setminus e}"/>, that is all we need in order to calculate: </p>
<p align="center"><img alt="\displaystyle  \begin{array}{rcl}  R_{G,\alpha,\beta}(x,y) &amp;=&amp; \alpha R_{G \setminus e,\alpha,\beta}(x,y) \;+\; \beta R_{G \backslash\!\backslash e,\alpha,\beta}(x,y)\\ &amp;=&amp; \alpha \alpha^{|E|-1}\rho^n R_{G\setminus e}(\frac{x}{\rho}, \rho y) \;+\; \beta \alpha^{|E|-1}\rho^{n-2} R_{G \backslash\!\backslash e}(\frac{x}{\rho}, \rho y)\\ &amp;=&amp; \alpha^{|E|}\rho^n R_{G\setminus e}(\frac{x}{\rho}, \rho y) \;+\; \rho^2 \alpha^{|E|}\rho^{n-2} R_{G \backslash\!\backslash e}(\frac{x}{\rho}, \rho y)\\ &amp;=&amp; \alpha^{|E|} \rho^n (R_{G\setminus e}(\frac{x}{\rho}, \rho y) \;+\; R_{G\backslash\!\backslash e}(\frac{x}{\rho}, \rho y))\\ &amp;=&amp; \alpha^{|E|} \rho^n R_G(\frac{x}{\rho}, \rho y). \;\Box \end{array} " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Cbegin%7Barray%7D%7Brcl%7D++R_%7BG%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%26%3D%26+%5Calpha+R_%7BG+%5Csetminus+e%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%5C%3B%2B%5C%3B+%5Cbeta+R_%7BG+%5Cbackslash%5C%21%5Cbackslash+e%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29%5C%5C+%26%3D%26+%5Calpha+%5Calpha%5E%7B%7CE%7C-1%7D%5Crho%5En+R_%7BG%5Csetminus+e%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29+%5C%3B%2B%5C%3B+%5Cbeta+%5Calpha%5E%7B%7CE%7C-1%7D%5Crho%5E%7Bn-2%7D+R_%7BG+%5Cbackslash%5C%21%5Cbackslash+e%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29%5C%5C+%26%3D%26+%5Calpha%5E%7B%7CE%7C%7D%5Crho%5En+R_%7BG%5Csetminus+e%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29+%5C%3B%2B%5C%3B+%5Crho%5E2+%5Calpha%5E%7B%7CE%7C%7D%5Crho%5E%7Bn-2%7D+R_%7BG+%5Cbackslash%5C%21%5Cbackslash+e%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29%5C%5C+%26%3D%26+%5Calpha%5E%7B%7CE%7C%7D+%5Crho%5En+%28R_%7BG%5Csetminus+e%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29+%5C%3B%2B%5C%3B+R_%7BG%5Cbackslash%5C%21%5Cbackslash+e%7D%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29%29%5C%5C+%26%3D%26+%5Calpha%5E%7B%7CE%7C%7D+%5Crho%5En+R_G%28%5Cfrac%7Bx%7D%7B%5Crho%7D%2C+%5Crho+y%29.+%5C%3B%5CBox+%5Cend%7Barray%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  \begin{array}{rcl}  R_{G,\alpha,\beta}(x,y) &amp;=&amp; \alpha R_{G \setminus e,\alpha,\beta}(x,y) \;+\; \beta R_{G \backslash\!\backslash e,\alpha,\beta}(x,y)\\ &amp;=&amp; \alpha \alpha^{|E|-1}\rho^n R_{G\setminus e}(\frac{x}{\rho}, \rho y) \;+\; \beta \alpha^{|E|-1}\rho^{n-2} R_{G \backslash\!\backslash e}(\frac{x}{\rho}, \rho y)\\ &amp;=&amp; \alpha^{|E|}\rho^n R_{G\setminus e}(\frac{x}{\rho}, \rho y) \;+\; \rho^2 \alpha^{|E|}\rho^{n-2} R_{G \backslash\!\backslash e}(\frac{x}{\rho}, \rho y)\\ &amp;=&amp; \alpha^{|E|} \rho^n (R_{G\setminus e}(\frac{x}{\rho}, \rho y) \;+\; R_{G\backslash\!\backslash e}(\frac{x}{\rho}, \rho y))\\ &amp;=&amp; \alpha^{|E|} \rho^n R_G(\frac{x}{\rho}, \rho y). \;\Box \end{array} "/></p>
<p>
</p><p/><h2> Representation Theorem </h2><p/>
<p/><p>
The analogous recipe theorem in Oxley and Whittle’s paper bases everything on their <em>rank-generating function</em> for an arbitrary 2-polymatroid <img alt="{(E,f)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28E%2Cf%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(E,f)}"/>: </p>
<p align="center"><img alt="\displaystyle  S_E(x,y) = \sum_{A \subseteq E}x^{f(E) - f(A)} y ^{2|A| - f(A)}. " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++S_E%28x%2Cy%29+%3D+%5Csum_%7BA+%5Csubseteq+E%7Dx%5E%7Bf%28E%29+-+f%28A%29%7D+y+%5E%7B2%7CA%7C+-+f%28A%29%7D.+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  S_E(x,y) = \sum_{A \subseteq E}x^{f(E) - f(A)} y ^{2|A| - f(A)}. "/></p>
<p>Although isolated nodes are immaterial for <i>graphical</i> 2-polymatroids, we augment them to include <img alt="{\bullet}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbullet%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bullet}"/> and <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/>. We replace <img alt="{f(E)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bf%28E%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{f(E)}"/> by the signed node count <img alt="{n}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n}"/> and use its negative portion <img alt="{n_{\ominus}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn_%7B%5Cominus%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n_{\ominus}}"/> separately. By characterizing <img alt="{R_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_G}"/>, the recipe theorem extends this representation even further:</p>
<blockquote><p><b>Theorem 3 (Representation Theorem)</b> <em><a name="representation"/> For any G2PM <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{G}"/> with rank function <img alt="{r = r_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br+%3D+r_G%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{r = r_G}"/>, <a name="rgf"/></em></p><em><a name="rgf">
<p align="center"><img alt="\displaystyle  R_G(x,y) = (xy)^{n_{\ominus}} \sum_{A \subseteq E}x^{n - r(A)} y ^{2|A| - r(A)}. \ \ \ \ \ (3)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++R_G%28x%2Cy%29+%3D+%28xy%29%5E%7Bn_%7B%5Cominus%7D%7D+%5Csum_%7BA+%5Csubseteq+E%7Dx%5E%7Bn+-+r%28A%29%7D+y+%5E%7B2%7CA%7C+-+r%28A%29%7D.+%5C+%5C+%5C+%5C+%5C+%283%29&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="\displaystyle  R_G(x,y) = (xy)^{n_{\ominus}} \sum_{A \subseteq E}x^{n - r(A)} y ^{2|A| - r(A)}. \ \ \ \ \ (3)"/></p>
</a></em><p><em><a name="rgf"/> </em>
</p></blockquote>
<p/><p>
This says that <img alt="{R_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_G}"/> is just an extension of <img alt="{S_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BS_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{S_G}"/> from G2PMs to our augmented class of graphs. We give a fresh proof of the theorem.</p>
<p>
<em>Proof:</em>  For the completely empty graph, there is just the term <img alt="{A = \emptyset}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BA+%3D+%5Cemptyset%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{A = \emptyset}"/> and all exponents are zero, so the value is <img alt="{1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{1}"/> as required. For <img alt="{\bullet}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbullet%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bullet}"/>, we have the term for <img alt="{A = \emptyset}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BA+%3D+%5Cemptyset%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{A = \emptyset}"/> with <img alt="{n = 1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn+%3D+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n = 1}"/> (and <img alt="{n_{\ominus} = 0}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn_%7B%5Cominus%7D+%3D+0%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n_{\ominus} = 0}"/>), which leaves <img alt="{x}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bx%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{x}"/>. For <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/>, we have <img alt="{n = -1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn+%3D+-1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n = -1}"/> and also <img alt="{n_{\ominus} = 1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn_%7B%5Cominus%7D+%3D+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n_{\ominus} = 1}"/>. The result is <img alt="{x^{-1}xy = y}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bx%5E%7B-1%7Dxy+%3D+y%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{x^{-1}xy = y}"/>, again as required. </p>
<p>
Because this is proving confluence, the only case of disjoint graphs we need to consider is adding one <img alt="{\bullet}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbullet%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bullet}"/> or <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/>. The above shows that the effect is to multiply by <img alt="{x}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bx%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{x}"/>, or respectively, by <img alt="{y}" class="latex" src="https://s0.wp.com/latex.php?latex=%7By%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{y}"/>. To save the case of recursing on <img alt="{e = \bigcirc}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be+%3D+%5Cbigcirc%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e = \bigcirc}"/> below, we include that here: <img alt="{G \setminus e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%5Csetminus+e%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G \setminus e}"/> is just <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> without adding the circle, whereas <img alt="{G \backslash\!\backslash e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%5Cbackslash%5C%21%5Cbackslash+e%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G \backslash\!\backslash e}"/> adds two <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/>, so the net effect is multiplying by <img alt="{(1 + y^2)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%281+%2B+y%5E2%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(1 + y^2)}"/>, again as required.</p>
<p>
This also lets us suppose that <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> has no isolated nodes, so <img alt="{n = r(E)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn+%3D+r%28E%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n = r(E)}"/> after all, and we may let <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/> be any member of <img alt="{E}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BE%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{E}"/>. Again write <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/> for <img alt="{G\backslash\!\backslash e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%5Cbackslash%5C%21%5Cbackslash+e%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G\backslash\!\backslash e}"/>; note that both <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/> and <img alt="{G \setminus e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG+%5Csetminus+e%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G \setminus e}"/> may have <img alt="{\bullet}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbullet%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bullet}"/> and/or <img alt="{\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\ominus}"/>. Consider subsets <img alt="{B}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BB%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{B}"/> of <img alt="{E}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BE%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{E}"/> that do not contain <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/>. Then <img alt="{r_{G \setminus e}(B) = r_G(B)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_%7BG+%5Csetminus+e%7D%28B%29+%3D+r_G%28B%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_{G \setminus e}(B) = r_G(B)}"/> Therefore when we begin the induction: </p>
<p align="center"><img alt="\displaystyle  \begin{array}{rcl}  R_G(x,y) &amp;=&amp; R_{G \setminus e}(x,y) + R_{G'}(x,y)\\ &amp;=&amp; \sum_{B \subseteq E \setminus \{e\}}x^{n - r(B)} y ^{2|B| - r(B)} + R_{G'}(x,y), \end{array} " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Cbegin%7Barray%7D%7Brcl%7D++R_G%28x%2Cy%29+%26%3D%26+R_%7BG+%5Csetminus+e%7D%28x%2Cy%29+%2B+R_%7BG%27%7D%28x%2Cy%29%5C%5C+%26%3D%26+%5Csum_%7BB+%5Csubseteq+E+%5Csetminus+%5C%7Be%5C%7D%7Dx%5E%7Bn+-+r%28B%29%7D+y+%5E%7B2%7CB%7C+-+r%28B%29%7D+%2B+R_%7BG%27%7D%28x%2Cy%29%2C+%5Cend%7Barray%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  \begin{array}{rcl}  R_G(x,y) &amp;=&amp; R_{G \setminus e}(x,y) + R_{G'}(x,y)\\ &amp;=&amp; \sum_{B \subseteq E \setminus \{e\}}x^{n - r(B)} y ^{2|B| - r(B)} + R_{G'}(x,y), \end{array} "/></p>
<p>the first term already gives us the part of the sum in (<a href="https://rjlipton.wordpress.com/feed/#rgf">3</a>) that is over <img alt="{B}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BB%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{B}"/> without <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/>. So we need only show that <a name="e1"/></p><a name="e1">
<p align="center"><img alt="\displaystyle  \sum_{B \subseteq E \setminus \{e\}}x^{n - r(B \cup \{e\})} y ^{2|B|+ 2 - r(B \cup \{e\})} = R_{G'}(x,y). \ \ \ \ \ (4)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Csum_%7BB+%5Csubseteq+E+%5Csetminus+%5C%7Be%5C%7D%7Dx%5E%7Bn+-+r%28B+%5Ccup+%5C%7Be%5C%7D%29%7D+y+%5E%7B2%7CB%7C%2B+2+-+r%28B+%5Ccup+%5C%7Be%5C%7D%29%7D+%3D+R_%7BG%27%7D%28x%2Cy%29.+%5C+%5C+%5C+%5C+%5C+%284%29&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  \sum_{B \subseteq E \setminus \{e\}}x^{n - r(B \cup \{e\})} y ^{2|B|+ 2 - r(B \cup \{e\})} = R_{G'}(x,y). \ \ \ \ \ (4)"/></p>
</a><p><a name="e1"/> Note that the edge set <img alt="{E'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BE%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{E'}"/> of <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/> can be identified with <img alt="{E \setminus \{e\}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BE+%5Csetminus+%5C%7Be%5C%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{E \setminus \{e\}}"/>, even though some edges may become loops or circles. If <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/> is a loop then <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/> still has <img alt="{n' = n - 2}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn%27+%3D+n+-+2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n' = n - 2}"/> but <img alt="{n_{\ominus} = 1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn_%7B%5Cominus%7D+%3D+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n_{\ominus} = 1}"/>. Thus we have by induction: <a name="e2"/></p><a name="e2">
<p align="center"><img alt="\displaystyle \begin{array}{rcl} R_{G'}(x,y) &amp;=&amp; (xy)^{n_{\ominus}}\sum_{B \subseteq E \setminus \{e\}}x^{n' - r'(B)} y ^{2|B| - r'(B)}\\ &amp;=&amp; (xy)^{n_{\ominus}}\sum_{B \subseteq E \setminus \{e\}}x^{n - 2 - r'(B)} y ^{2|B| - r'(B)}. \end{array}  \ \ \ \ \ (5)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+%5Cbegin%7Barray%7D%7Brcl%7D+R_%7BG%27%7D%28x%2Cy%29+%26%3D%26+%28xy%29%5E%7Bn_%7B%5Cominus%7D%7D%5Csum_%7BB+%5Csubseteq+E+%5Csetminus+%5C%7Be%5C%7D%7Dx%5E%7Bn%27+-+r%27%28B%29%7D+y+%5E%7B2%7CB%7C+-+r%27%28B%29%7D%5C%5C+%26%3D%26+%28xy%29%5E%7Bn_%7B%5Cominus%7D%7D%5Csum_%7BB+%5Csubseteq+E+%5Csetminus+%5C%7Be%5C%7D%7Dx%5E%7Bn+-+2+-+r%27%28B%29%7D+y+%5E%7B2%7CB%7C+-+r%27%28B%29%7D.+%5Cend%7Barray%7D++%5C+%5C+%5C+%5C+%5C+%285%29&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle \begin{array}{rcl} R_{G'}(x,y) &amp;=&amp; (xy)^{n_{\ominus}}\sum_{B \subseteq E \setminus \{e\}}x^{n' - r'(B)} y ^{2|B| - r'(B)}\\ &amp;=&amp; (xy)^{n_{\ominus}}\sum_{B \subseteq E \setminus \{e\}}x^{n - 2 - r'(B)} y ^{2|B| - r'(B)}. \end{array}  \ \ \ \ \ (5)"/></p>
</a><p><a name="e2">
Equating (</a><a href="https://rjlipton.wordpress.com/feed/#e1">4</a>) and (<a href="https://rjlipton.wordpress.com/feed/#e2">5</a>) as formal polynomials gives the same necessary and sufficient condition on the powers of <img alt="{x}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bx%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{x}"/> and <img alt="{y}" class="latex" src="https://s0.wp.com/latex.php?latex=%7By%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{y}"/>: </p>
<p align="center"><img alt="\displaystyle  r(B \cup \{e\}) = r'(B) + (2 - n_{\ominus}). " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++r%28B+%5Ccup+%5C%7Be%5C%7D%29+%3D+r%27%28B%29+%2B+%282+-+n_%7B%5Cominus%7D%29.+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  r(B \cup \{e\}) = r'(B) + (2 - n_{\ominus}). "/></p>
<p>This is true because <img alt="{B \cup \{e\}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BB+%5Ccup+%5C%7Be%5C%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{B \cup \{e\}}"/> always touches the one-or-two nodes that are exploded away, whereas <img alt="{B}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BB%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{B}"/> does not touch them in <img alt="{G'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G'}"/> (but touches everything else <img alt="{B}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BB%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{B}"/> touches in <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/>) and the difference is <img alt="{2 - n_{\ominus}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B2+-+n_%7B%5Cominus%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{2 - n_{\ominus}}"/>. <img alt="\Box" class="latex" src="https://s0.wp.com/latex.php?latex=%5CBox&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\Box"/></p>
<p>
Combined with the recipe theorem we obtain the following, which re-emphasizes that <img alt="{R_{G,\alpha,\beta}(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7BG%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{G,\alpha,\beta}(x,y)}"/> for real <img alt="{\alpha,\beta}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Calpha%2C%5Cbeta%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\alpha,\beta}"/> is always a real polynomial:</p>
<blockquote><p><b>Corollary 4</b> <em><a name="realcor"/> For any augmented G2PM <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{G}"/> with rank function <img alt="{r}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{r}"/>, and all <img alt="{\alpha,\beta \neq 0}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Calpha%2C%5Cbeta+%5Cneq+0%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{\alpha,\beta \neq 0}"/>: <a name="rgfreal"/></em></p><em><a name="rgfreal">
<p align="center"><img alt="\displaystyle  R_{G,\alpha,\beta}(x,y) = (xy)^{n_{\ominus}} \sum_{A \subseteq E} \beta^{|A|} \alpha^{|E \setminus A|} x^{n - r(A)} y ^{2|A| - r(A)}. \ \ \ \ \ (5)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++R_%7BG%2C%5Calpha%2C%5Cbeta%7D%28x%2Cy%29+%3D+%28xy%29%5E%7Bn_%7B%5Cominus%7D%7D+%5Csum_%7BA+%5Csubseteq+E%7D+%5Cbeta%5E%7B%7CA%7C%7D+%5Calpha%5E%7B%7CE+%5Csetminus+A%7C%7D+x%5E%7Bn+-+r%28A%29%7D+y+%5E%7B2%7CA%7C+-+r%28A%29%7D.+%5C+%5C+%5C+%5C+%5C+%285%29&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="\displaystyle  R_{G,\alpha,\beta}(x,y) = (xy)^{n_{\ominus}} \sum_{A \subseteq E} \beta^{|A|} \alpha^{|E \setminus A|} x^{n - r(A)} y ^{2|A| - r(A)}. \ \ \ \ \ (5)"/></p>
</a></em><p><em><a name="rgfreal"/> </em>
</p></blockquote>
<p>
</p><p/><h2> The Points </h2><p/>
<p/><p>
The quick finish to the proof of Theorem <a href="https://rjlipton.wordpress.com/feed/#representation">3</a>—combining what could be several cases of <img alt="{r(B \cup \{e\})}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br%28B+%5Ccup+%5C%7Be%5C%7D%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r(B \cup \{e\})}"/> versus <img alt="{r(B)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br%28B%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r(B)}"/> into one—can also be viewed through the lens of duality. Then the complement <img alt="{B'}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BB%27%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{B'}"/> of <img alt="{B \cup \{e\}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BB+%5Ccup+%5C%7Be%5C%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{B \cup \{e\}}"/> in <img alt="{E}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BE%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{E}"/> does not include <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/>, so <img alt="{r^*(B')}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br%5E%2A%28B%27%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r^*(B')}"/> is unchanged by removing <img alt="{e}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Be%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{e}"/>. As we noted in the previous <a href="https://rjlipton.wordpress.com/2020/02/01/subliminal-graph-duals/">post</a>, however, <img alt="{r^*}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br%5E%2A%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r^*}"/> need not be the rank function of a graph. Thus the proof gives a handle on manipulating a wider class of structures via graph theory.  It moreover seems extendable to all 2-polymatroids augmented with <img alt="{\bullet,\ominus}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbullet%2C%5Cominus%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\bullet,\ominus}"/>, so as to give <img alt="{R_E}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_E%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_E}"/> extending <img alt="{S_E}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BS_E%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{S_E}"/>. </p>
<p>
The beauty of the recipe theorem is that a whole host of recursions become encoded by evaluations of the polynomials <img alt="{R_G(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_G%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_G(x,y)}"/>. As we <a href="https://rjlipton.wordpress.com/2019/06/17/contraction-and-explosion/">noted</a> with the Tutte polynomial <img alt="{T_G(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BT_G%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{T_G(x,y)}"/> and <a href="https://rjlipton.wordpress.com/2019/08/26/a-matroid-quantum-connection/">with</a> the Oxley-Whittle polynomial <img alt="{S_G(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BS_G%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{S_G(x,y)}"/>, evaluations of them at certain points <img alt="{(x_0,y_0)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28x_0%2Cy_0%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(x_0,y_0)}"/> convey information about the graphs. For many points <img alt="{(x_0,y_0)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28x_0%2Cy_0%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(x_0,y_0)}"/> the information is <img alt="{\mathsf{\#P}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7B%5C%23P%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\mathsf{\#P}}"/>-hard.</p>
<p>
The case we care most about now is <img alt="{\alpha = 1}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Calpha+%3D+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\alpha = 1}"/>, <img alt="{\beta = -\frac{1}{2}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cbeta+%3D+-%5Cfrac%7B1%7D%7B2%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\beta = -\frac{1}{2}}"/>. We <a href="https://rjlipton.wordpress.com/2019/08/26/a-matroid-quantum-connection/">showed</a> how this evaluates the tractable subclass of quantum <em>stabilizer circuits</em>. This makes <img alt="{\rho = \sqrt{\beta/\alpha}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Crho+%3D+%5Csqrt%7B%5Cbeta%2F%5Calpha%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\rho = \sqrt{\beta/\alpha}}"/> imaginary, but by Corollary <a href="https://rjlipton.wordpress.com/feed/#realcor">4</a> the values at real points are real. </p>
<p>
When <img alt="{y = 2}" class="latex" src="https://s0.wp.com/latex.php?latex=%7By+%3D+2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{y = 2}"/> we have <img alt="{\rho y = \pm \sqrt{2}i}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Crho+y+%3D+%5Cpm+%5Csqrt%7B2%7Di%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\rho y = \pm \sqrt{2}i}"/>, so the value <img alt="{R_{G,1,-1/2}(x,2)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7BG%2C1%2C-1%2F2%7D%28x%2C2%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{G,1,-1/2}(x,2)}"/> agrees with the polynomial <img alt="{Q(x)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BQ%28x%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{Q(x)}"/> in that post. The fact that <img alt="{(\rho y)^2 = -2}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%28%5Crho+y%29%5E2+%3D+-2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(\rho y)^2 = -2}"/> evades the <img alt="{\mathsf{\#P}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7B%5C%23P%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\mathsf{\#P}}"/>-hardness technique in the <a href="https://bura.brunel.ac.uk/bitstream/2438/818/1/polymatroid.pdf">paper</a> by Steve Noble which we also discussed there. So let us now abbreviate <img alt="{R_{G,1,-1/2}(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_%7BG%2C1%2C-1%2F2%7D%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_{G,1,-1/2}(x,y)}"/> as <img alt="{Q_G(x,y)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BQ_G%28x%2Cy%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{Q_G(x,y)}"/>. Then <img alt="{Q_G(1,2)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BQ_G%281%2C2%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{Q_G(1,2)}"/> evaluates stabilizer circuits in polynomial time.</p>
<blockquote><p><b> </b> <em> What other points <img alt="{Q_G(x_0,y_0)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BQ_G%28x_0%2Cy_0%29%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{Q_G(x_0,y_0)}"/> are easy to evaluate, given <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{G}"/>? </em>
</p></blockquote>
<p/><p>
The point <img alt="{(0,2)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%280%2C2%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{(0,2)}"/> may even be nontrivial. If <img alt="{G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BG%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{G}"/> has no isolated nodes then the sum is over spanning edge-subsets <img alt="{A}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BA%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{A}"/> and becomes </p>
<p align="center"><img alt="\displaystyle  Q_{G}(0,2) = \sum_{\text{spanning} A \subseteq E} (-\frac{1}{2})^{|A|} 2 ^{2|A| - n} = \frac{1}{2^n} \sum_{\text{spanning} A \subseteq E} (-2)^{|A|}. " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++Q_%7BG%7D%280%2C2%29+%3D+%5Csum_%7B%5Ctext%7Bspanning%7D+A+%5Csubseteq+E%7D+%28-%5Cfrac%7B1%7D%7B2%7D%29%5E%7B%7CA%7C%7D+2+%5E%7B2%7CA%7C+-+n%7D+%3D+%5Cfrac%7B1%7D%7B2%5En%7D+%5Csum_%7B%5Ctext%7Bspanning%7D+A+%5Csubseteq+E%7D+%28-2%29%5E%7B%7CA%7C%7D.+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  Q_{G}(0,2) = \sum_{\text{spanning} A \subseteq E} (-\frac{1}{2})^{|A|} 2 ^{2|A| - n} = \frac{1}{2^n} \sum_{\text{spanning} A \subseteq E} (-2)^{|A|}. "/></p>
<p>Is this in polynomial time?</p>
<p>
</p><p/><h2> Open Problems </h2><p/>
<p/><p>
What more can we gain from this augmentation and streamlining of Tutte-Grothendieck invariants? Can we find further characterizations of the polynomials <img alt="{R_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R_G}"/> and <img alt="{Q_G}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BQ_G%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{Q_G}"/>? What can be done with <img alt="{k}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bk%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{k}"/>-polymatroids with <img alt="{k &gt; 2}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bk+%3E+2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{k &gt; 2}"/>, which might allow evaluating more quantum circuits?</p>
<p/><p><br/>
[some word improvements]</p></font></font></div>
    </content>
    <updated>2020-02-11T23:40:19Z</updated>
    <published>2020-02-11T23:40:19Z</published>
    <category term="All Posts"/>
    <category term="graph isomorphism"/>
    <category term="Ideas"/>
    <category term="2-polymatroids"/>
    <category term="counting"/>
    <category term="duality"/>
    <category term="graphs"/>
    <category term="Grothendieck"/>
    <category term="invariants"/>
    <category term="matroids"/>
    <category term="quantum circuits"/>
    <category term="rank-generation polynomial"/>
    <category term="Tutte polynomial"/>
    <author>
      <name>KWRegan</name>
    </author>
    <source>
      <id>https://rjlipton.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://rjlipton.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://rjlipton.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://rjlipton.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://rjlipton.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>a personal view of the theory of computation</subtitle>
      <title>Gödel’s Lost Letter and P=NP</title>
      <updated>2020-02-13T12:20:34Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://cstheory-jobs.org/2020/02/11/postdoc-in-quantum-and-classical-algorithms-at-university-of-warwick-uk-apply-by-march-8-2020/</id>
    <link href="https://cstheory-jobs.org/2020/02/11/postdoc-in-quantum-and-classical-algorithms-at-university-of-warwick-uk-apply-by-march-8-2020/" rel="alternate" type="text/html"/>
    <title>Postdoc in quantum and classical algorithms at University of Warwick, UK (apply by March 8, 2020)</title>
    <summary>We invite applications for a postdoc position, hosted by Tom Gur at the University of Warwick. The position is part of the UKRI Future Leaders project “Foundations of classical and quantum verifiable computing”, focused on interactive proofs, coding theory, and sublinear-time algorithms, both in the classical and quantum settings. Please apply via the link below […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>We invite applications for a postdoc position, hosted by Tom Gur at the University of Warwick. The position is part of the UKRI Future Leaders project “Foundations of classical and quantum verifiable computing”, focused on interactive proofs, coding theory, and sublinear-time algorithms, both in the classical and quantum settings.</p>
<p>Please apply via the link below or contact Tom directly.</p>
<p>Website: <a href="https://atsv7.wcn.co.uk/search_engine/jobs.cgi?SID=amNvZGU9MTg2MDg3NCZ2dF90ZW1wbGF0ZT0xNDU3Jm93bmVyPTUwNjI0NTImb3duZXJ0eXBlPWZhaXImYnJhbmRfaWQ9MCZ2YWNfeHRyYTUwNjI0NTIuNTJfNTA2MjQ1Mj0yMzk5MjEmcG9zdGluZ19jb2RlPTYzNQ==">https://atsv7.wcn.co.uk/search_engine/jobs.cgi?SID=amNvZGU9MTg2MDg3NCZ2dF90ZW1wbGF0ZT0xNDU3Jm93bmVyPTUwNjI0NTImb3duZXJ0eXBlPWZhaXImYnJhbmRfaWQ9MCZ2YWNfeHRyYTUwNjI0NTIuNTJfNTA2MjQ1Mj0yMzk5MjEmcG9zdGluZ19jb2RlPTYzNQ==</a><br/>
Email: tom.gur@warwick.ac.uk</p></div>
    </content>
    <updated>2020-02-11T14:19:54Z</updated>
    <published>2020-02-11T14:19:54Z</published>
    <category term="Uncategorized"/>
    <author>
      <name>shacharlovett</name>
    </author>
    <source>
      <id>https://cstheory-jobs.org</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://cstheory-jobs.org/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://cstheory-jobs.org" rel="alternate" type="text/html"/>
      <link href="https://cstheory-jobs.org/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://cstheory-jobs.org/?pushpress=hub" rel="hub" type="text/html"/>
      <title>Theoretical Computer Science Jobs</title>
      <updated>2020-02-13T12:20:38Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://gilkalai.wordpress.com/?p=19277</id>
    <link href="https://gilkalai.wordpress.com/2020/02/08/the-largest-clique-in-the-paley-graph-unexpected-significant-progress-and-surprising-connections/" rel="alternate" type="text/html"/>
    <title>The largest clique in the Paley Graph: unexpected significant progress and surprising connections.</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">The result on Paley Graphs by Hanson and Petridis On May 2019, Brandon Hanson and Giorgis Petridis posed a paper on the arXive: Refined Estimates Concerning Sumsets Contained in the Roots of Unity. The abstract was almost as short as … <a href="https://gilkalai.wordpress.com/2020/02/08/the-largest-clique-in-the-paley-graph-unexpected-significant-progress-and-surprising-connections/">Continue reading <span class="meta-nav">→</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h2>The result on Paley Graphs by Hanson and Petridis</h2>
<p>On May 2019, Brandon Hanson and Giorgis Petridis posed a paper on the arXive: <a href="https://arxiv.org/abs/1905.09134">Refined Estimates Concerning Sumsets Contained in the Roots of Unity.</a> The <strong>abstract</strong> was almost as short as the title (the paper is short as well!):</p>
<blockquote><p><em>We prove that the clique number of the Paley graph is at most <img alt="\sqrt {p/2}+1" class="latex" src="https://s0.wp.com/latex.php?latex=%5Csqrt+%7Bp%2F2%7D%2B1&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\sqrt {p/2}+1"/>, and that any supposed additive decompositions of the set of quadratic residues can only come from co-Sidon sets.</em></p></blockquote>
<p>Let me elaborate on the first half of the abstract.</p>
<p>Let <img alt="q" class="latex" src="https://s0.wp.com/latex.php?latex=q&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="q"/> be a prime power such that <img alt="q=1 (\mod 4)" class="latex" src="https://s0.wp.com/latex.php?latex=q%3D1+%28%5Cmod+4%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="q=1 (\mod 4)"/>. This choice implies that in <img alt="F_q" class="latex" src="https://s0.wp.com/latex.php?latex=F_q&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F_q"/> the difference of two numbers, <img alt="a-b" class="latex" src="https://s0.wp.com/latex.php?latex=a-b&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="a-b"/>, is a square iff <img alt="-(a-b)" class="latex" src="https://s0.wp.com/latex.php?latex=-%28a-b%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="-(a-b)"/> is a square, so the Paley graph we are going to define is a simple graph.</p>
<p>In the <a href="https://en.wikipedia.org/wiki/Paley_graph"><strong>Payley graph</strong></a> the vertices are the elements of <img alt="F_q" class="latex" src="https://s0.wp.com/latex.php?latex=F_q&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F_q"/> and two are adjacent iff their difference is a square.</p>
<p>When the field is <img alt="F_p" class="latex" src="https://s0.wp.com/latex.php?latex=F_p&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F_p"/>, where <img alt="p" class="latex" src="https://s0.wp.com/latex.php?latex=p&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="p"/> is prime, then the Paley graph is conjectured to be an excellent construction for a Ramsey graphs, the largest complete subgraph (which has the same size as its largest empty subgraph since it is self-complementary) is conjectured to be <img alt="\log(p)\log \log (p)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Clog%28p%29%5Clog+%5Clog+%28p%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\log(p)\log \log (p)"/>. This is actually a lower bound for infinitely many primes, proved by Montgomery under the assumption that the generalized Riemann hypothesis holds.</p>
<p>The upper bound (which is easy to prove) is <img alt="\sqrt p" class="latex" src="https://s0.wp.com/latex.php?latex=%5Csqrt+p&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\sqrt p"/>. This upper bound is sharp for the field <img alt="F_{p^2}." class="latex" src="https://s0.wp.com/latex.php?latex=F_%7Bp%5E2%7D.&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F_{p^2}."/> (This is a very nice construction of <a href="http://people.sabanciuniv.edu/~mlavrauw/Aart/aart_and_combinatorics.html">Aart Blokhuis</a>.)</p>
<p>There was practically no improvement on the <img alt="\sqrt p" class="latex" src="https://s0.wp.com/latex.php?latex=%5Csqrt+p&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\sqrt p"/> upper bound until 2013, when Bachoc, Ruzsa and Matolcsi, proved that the <img alt="\sqrt p-1" class="latex" src="https://s0.wp.com/latex.php?latex=%5Csqrt+p-1&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\sqrt p-1"/> bound holds for infinitely many primes.</p>
<p>Hanson and Petridis thus improved the upper bound significantly! They gave the upper bound <img alt="\sqrt{p/2}+1" class="latex" src="https://s0.wp.com/latex.php?latex=%5Csqrt%7Bp%2F2%7D%2B1&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\sqrt{p/2}+1"/> on the clique size of the Paley graph. Their  proof uses Stepanov’s method.</p>
<h2>The result of Di Benedetto, Solymosi, and White on directions in Cartesian products</h2>
<p>A couple weeks ago, Daniel Di Benedetto, József Solymosi, and Ethan White posted a paper on the arxive: <a href="https://arxiv.org/abs/2001.06994">On the directions determined by a Cartesian product in an affine Galois plane</a>. Also here the <strong>abstract</strong> is also quite short (and so is the entire paper!).</p>
<blockquote><p><em>We prove that the number of directions contained in a set of the form <img alt="A \times B \subset AG(2,p)" class="latex" src="https://s0.wp.com/latex.php?latex=A+%5Ctimes+B+%5Csubset+AG%282%2Cp%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="A \times B \subset AG(2,p)"/>, where <img alt="p" class="latex" src="https://s0.wp.com/latex.php?latex=p&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="p"/> is prime, is at least <img alt="|A||B| -\min\{|A|,|B|\}+2" class="latex" src="https://s0.wp.com/latex.php?latex=%7CA%7C%7CB%7C+-%5Cmin%5C%7B%7CA%7C%2C%7CB%7C%5C%7D%2B2&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="|A||B| -\min\{|A|,|B|\}+2"/>. Here <img alt="A" class="latex" src="https://s0.wp.com/latex.php?latex=A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="A"/> and <img alt="B" class="latex" src="https://s0.wp.com/latex.php?latex=B&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="B"/> are subsets of <img alt="GF(p)" class="latex" src="https://s0.wp.com/latex.php?latex=GF%28p%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="GF(p)"/> each with at least two elements and <img alt="|A||B|&lt;p" class="latex" src="https://s0.wp.com/latex.php?latex=%7CA%7C%7CB%7C%3Cp&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="|A||B|&lt;p"/>. This bound is tight for an infinite class of examples. Our main tool is the use of the Rédei polynomial with Szőnyi’s extension</em>.</p></blockquote>
<h3>A surprising connection</h3>
<p>Now, if you have a set <img alt="A" class="latex" src="https://s0.wp.com/latex.php?latex=A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="A"/> where the difference between any two elements is a square then in <img alt="A \times A" class="latex" src="https://s0.wp.com/latex.php?latex=A+%5Ctimes+A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="A \times A"/> all directions, <img alt="(a-b)/(c-d)" class="latex" src="https://s0.wp.com/latex.php?latex=%28a-b%29%2F%28c-d%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="(a-b)/(c-d)"/>, are also squares. To Daniel, József, and Ethan’s  great surprise applying their bound on the clique number of the Paley graph gave the very same bound as Hanson and Petridis!</p>
<p>I am thankful to Józsi Solymosi for very helpful clarifications.</p>
<p><a href="https://gilkalai.files.wordpress.com/2020/02/1024px-paley13.svg_.png"><img alt="" class="alignnone size-full wp-image-19289" height="640" src="https://gilkalai.files.wordpress.com/2020/02/1024px-paley13.svg_.png?w=640&amp;h=640" width="640"/></a></p>
<p><span style="color: #ff0000;">Payley graph with 13 vertices (source: <a href="https://en.wikipedia.org/wiki/Paley_graph">wikipedea</a>)</span></p>
<h3><em>A quick Sum-Product update, and associations.</em></h3>
<p>Now that I mention Józsi’s work let me also use this opportunity to give a quick update about Erdős-Szemeredi’s sum product conjecture. In an <a href="https://gilkalai.wordpress.com/2008/07/17/extermal-combinatorics-ii-some-geometry-and-number-theory/">old post</a> from 2009, I presented Elekes’ pioneering geometric proof for his sum-product world record and gave a link to a paper and <a href="https://ilaba.wordpress.com/2008/06/24/the-sum-product-problem/">a blog post</a> written by Izabella Laba about József Solymosi’s new (then) world record. I just saw <a href="https://www.quantamagazine.org/the-sum-product-problem-shows-how-addition-and-multiplication-constrain-each-other-20190206/?fbclid=IwAR2MqPEVRiFYhL5MIKCwhhIn038DDCwm4XZumNOw6n4XwKoN6F9uQ88MwbA">an article by Kevin Hartnett about the problem</a> in Quanta Magazine describing several subsequent records. The current world record is <a href="https://arxiv.org/abs/1803.04637">in a 2019 paper by George Shakan</a>.   (Sergei Konyagin and Ilya Shkredov broke József’s record in 2015, and the new record improved a 2016 world record by Misha Rudnev, Ilya Shkredov and Sophie Stevens; I also updated my related <a href="https://mathoverflow.net/a/217602/1532">MO answer.</a>) Of course, the sum-product phenomena is a huge area with amazing applications (See, <a href="https://terrytao.wordpress.com/2007/12/06/milliman-lecture-iii-sum-product-estimates-expanders-and-exponential-sums/">here</a>, here, <a href="https://terrytao.wordpress.com/2014/05/07/stickiness-graininess-planiness-and-a-sum-product-approach-to-the-kakeya-problem/">here,</a> and <a href="https://ilaba.wordpress.com/2008/12/25/expanders-and-the-sum-product-problem/">here</a>; I recall that Jean Bourgain referred to it as a gold mine or something like that). Now, talking about sum-product theorems, and about Bourgain, and about Quanta Magazine, I should mention a lovely <a href="https://www.quantamagazine.org/alex-kontorovich-on-the-absolute-truth-of-pure-math-20200128/">Quanta podcast featuring Alex Kontorovich interviewed by Steven Strogatz </a> .</p></div>
    </content>
    <updated>2020-02-08T20:10:35Z</updated>
    <published>2020-02-08T20:10:35Z</published>
    <category term="Combinatorics"/>
    <category term="Number theory"/>
    <category term="Brandon Hanson"/>
    <category term="Daniel Di Benedetto"/>
    <category term="Ethan White"/>
    <category term="Giorgis Petridis"/>
    <category term="Jozsef Solymosi"/>
    <category term="Paley graph"/>
    <author>
      <name>Gil Kalai</name>
    </author>
    <source>
      <id>https://gilkalai.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://gilkalai.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://gilkalai.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://gilkalai.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://gilkalai.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>Gil Kalai's blog</subtitle>
      <title>Combinatorics and more</title>
      <updated>2020-02-13T12:20:29Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://kamathematics.wordpress.com/?p=40</id>
    <link href="https://kamathematics.wordpress.com/2020/02/08/icalp-and-lics-2020-relocation-and-extended-deadline/" rel="alternate" type="text/html"/>
    <title>ICALP (and LICS) 2020 – Relocation and Extended Deadline</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Due to the Wuhan coronavirus outbreak, the organizers of ICALP and LICS have made the difficult decision to relocate both (co-located) conferences from Beijing, China, to Saarbrücken, Germany. Speaking specifically about ICALP now (I do not have further information about LICS): As a result of previous uncertainty regarding the situation, the deadline has been extended … <a class="more-link" href="https://kamathematics.wordpress.com/2020/02/08/icalp-and-lics-2020-relocation-and-extended-deadline/">Continue reading<span class="screen-reader-text"> "ICALP (and LICS) 2020 – Relocation and Extended Deadline"</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Due to the Wuhan coronavirus outbreak, the organizers of ICALP and LICS have made the difficult decision to relocate both (co-located) conferences from Beijing, China, to Saarbrücken, Germany. Speaking specifically about ICALP now (I do not have further information about LICS): As a result of previous uncertainty regarding the situation, the deadline has been extended by about six days, until Tuesday February 18, 2020, at 6 AM GMT. The dates of the conference remain (roughly) the same, July 8 – 11, 2020. <br/>The following is a more official message from ICALP Track A Chair, Artur Czumaj.</p>



<hr class="wp-block-separator"/>



<p>The ICALP and the LICS steering committee have agreed together with the conference chairs in Beijing to relocate the two conferences.<br/>ICALP and LICS 2020 will take place in <strong>Saarbrücken</strong>, Germany, July 8 – 11 2020 (with satellite workshops on July 6 – 7 2020).<br/>The deadline is extended, see below.</p>



<p><strong>Call for Papers – ICALP 2020</strong><br/><strong>July 8 – 11 2020, Saarbrücken, Germany</strong></p>



<p><strong>NEW Paper submission deadline: Tuesday February 18, 2020, 6am GMT</strong><br/><a href="https://easychair.org/conferences/?conf=icalp2020">https://easychair.org/conferences/?conf=icalp2020</a></p>



<p>ICALP (International Colloquium on Automata, Languages and Programming) is the main European conference in Theoretical Computer Science and annual meeting of the European Association for Theoretical Computer Science (EATCS). ICALP 2020 will be hosted on the Saarland Informatics Campus in Saarbrücken, in co-location with LICS 2020 (ACM/IEEE Symposium on Logic in Computer Science).</p>



<p><strong>Invited speakers:</strong><br/>Track A: Virginia Vassilevska (MIT), Robert Krauthgamer (Weizmann)<br/>Track B: Stefan Kiefer (Oxford)<br/>Joint ICALP-LICS: Andrew Yao (Tsinghua), Jérôme Leroux (Bordeaux)</p>



<p><strong>Submission Guidelines:</strong> see <a href="https://easychair.org/conferences/?conf=icalp2020">https://easychair.org/conferences/?conf=icalp2020</a></p>



<p><strong>NEW Paper submission deadline: February 18</strong>, 2020, 6am GMT<br/>notifications: April 15, 2020<br/>camera ready: April 28, 2020</p>



<p>Topics: ICALP 2020 will have the two traditional tracks<br/>A (Algorithms, Complexity and Games – including Algorithmic Game Theory, Distributed Algorithms and Parallel, Distributed and External Memory Computing) and<br/>B (Automata, Logic, Semantics and Theory of Programming).<br/><strong><em>    (Notice that the old tracks A and C have been merged into a single track A.)</em></strong><br/>Papers presenting original, unpublished research on all aspects of theoretical computer science are sought.</p>



<p>Typical, but not exclusive topics are:</p>



<p>Track A — Algorithmic Aspects of Networks and Networking, Algorithms for Computational Biology, Algorithmic Game Theory, Combinatorial Optimization, Combinatorics in Computer Science, Computational Complexity, Computational Geometry, Computational Learning Theory, Cryptography, Data Structures, Design and Analysis of Algorithms, Foundations of Machine Learning, Foundations of Privacy, Trust and Reputation in Network, Network Models for Distributed Computing, Network Economics and Incentive-Based Computing Related to Networks, Network Mining and Analysis, Parallel, Distributed and External Memory Computing, Quantum Computing, Randomness in Computation, Theory of Security in Networks</p>



<p>Track B — Algebraic and Categorical Models, Automata, Games, and Formal Languages, Emerging and Non-standard Models of Computation, Databases, Semi-Structured Data and Finite Model Theory, Formal and Logical Aspects of Learning, Logic in Computer Science, Theorem Proving and Model Checking, Models of Concurrent, Distributed, and Mobile Systems, Models of Reactive, Hybrid and Stochastic Systems, Principles and Semantics of Programming Languages, Program Analysis and Transformation, Specification, Verification and Synthesis, Type Systems and Theory, Typed Calculi</p>



<p><strong>PC Track A chair: Artur Czumaj</strong> (University  of Warwick)<br/><strong>PC Track B chair: Anuj Dawar</strong> (University of Cambridge)</p>



<p>Contact<br/>All questions about submissions should be emailed to the PC Track chairs:<br/>Artur Czumaj <a href="mailto:A.Czumaj@warwick.ac.uk">A.Czumaj@warwick.ac.uk&lt;mailto:A.Czumaj@warwick.ac.uk&gt;</a><br/>Anuj Dawar <a href="mailto:Anuj.Dawar@cl.cam.ac.uk">Anuj.Dawar@cl.cam.ac.uk&lt;mailto:Anuj.Dawar@cl.cam.ac.uk&gt;</a></p></div>
    </content>
    <updated>2020-02-08T15:01:28Z</updated>
    <published>2020-02-08T15:01:28Z</published>
    <author>
      <name>Gautam</name>
    </author>
    <source>
      <id>https://kamathematics.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://kamathematics.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://kamathematics.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://kamathematics.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://kamathematics.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <title>Kamathematics</title>
      <updated>2020-02-13T12:21:45Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://cstheory-jobs.org/2020/02/08/postdoc-at-northwestern-and-ttic-as-part-of-ideal-apply-by-february-22-2020/</id>
    <link href="https://cstheory-jobs.org/2020/02/08/postdoc-at-northwestern-and-ttic-as-part-of-ideal-apply-by-february-22-2020/" rel="alternate" type="text/html"/>
    <title>Postdoc at Northwestern and TTIC (as part of IDEAL) (apply by February 22, 2020)</title>
    <summary>The Institute for Data, Econometrics, Algorithms, and Learning (IDEAL) invites applications for two postdoctoral fellowships starting Fall of 2020, to conduct inter-disciplinary research that focuses on the theoretical foundations of data science. One fellowship is based at the Toyota Technology Institute at Chicago (TTIC) and one fellowship is based at Northwestern University. Website: https://www.ideal.northwestern.edu/2020/02/04/postdocs/ Email: […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>The Institute for Data, Econometrics, Algorithms, and Learning (IDEAL) invites applications for two postdoctoral fellowships starting Fall of 2020, to conduct inter-disciplinary research that focuses on the theoretical foundations of data science. One fellowship is based at the Toyota Technology Institute at Chicago (TTIC) and one fellowship is based at Northwestern University.</p>
<p>Website: <a href="https://www.ideal.northwestern.edu/2020/02/04/postdocs/">https://www.ideal.northwestern.edu/2020/02/04/postdocs/</a><br/>
Email: admin@ideal.northwestern.edu</p></div>
    </content>
    <updated>2020-02-08T14:45:51Z</updated>
    <published>2020-02-08T14:45:51Z</published>
    <category term="Uncategorized"/>
    <author>
      <name>shacharlovett</name>
    </author>
    <source>
      <id>https://cstheory-jobs.org</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://cstheory-jobs.org/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://cstheory-jobs.org" rel="alternate" type="text/html"/>
      <link href="https://cstheory-jobs.org/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://cstheory-jobs.org/?pushpress=hub" rel="hub" type="text/html"/>
      <title>Theoretical Computer Science Jobs</title>
      <updated>2020-02-13T12:20:38Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://rjlipton.wordpress.com/?p=16647</id>
    <link href="https://rjlipton.wordpress.com/2020/02/07/counting-votes-by-humans/" rel="alternate" type="text/html"/>
    <title>Counting Votes By Humans</title>
    <summary>A new way to agree on calculations Cropped from ABC News source Troy Price is the Iowa Democratic Party Chair. He was in charge of Iowa’s primary vote. The vote totals were due Monday night but have not been finished, now three nights later, and may need to be re-tallied. At a press conference to […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>
<font color="#0044cc"><br/>
<em>A new way to agree on calculations</em><br/>
<font color="#000000"/></font></p><font color="#0044cc"><font color="#000000">
<table class="image alignright">
<tbody>
<tr>
<td>
<a href="https://rjlipton.files.wordpress.com/2020/02/tonyprice.jpg"><img alt="" class="alignright wp-image-16649" height="198" src="https://rjlipton.files.wordpress.com/2020/02/tonyprice.jpg?w=145&amp;h=198" width="145"/></a>
</td>
</tr>
<tr>
<td class="caption alignright"><font size="-2">Cropped from ABC News <a href="https://www.facebook.com/ABC13News/photos/a.10150267351592428/10157269745777428/?type=3&amp;theater">source</a></font></td>
</tr>
</tbody>
</table>
<p>
Troy Price is the Iowa Democratic Party Chair. He was in charge of Iowa’s primary vote. The vote totals were due Monday night but have not been finished, now three nights later, and may need to be re-tallied. At a press conference to explain the cause for the delay—mainly a failed phone app—Price was <a href="https://www.washingtonexaminer.com/news/reporter-hollers-at-iowa-democratic-party-chairman-how-can-anyone-trust-you-now">asked</a>, “How can anyone trust you now?”</p>
<p>
Today, Ken and I discuss a way to make counting votes quickly checkable by humans.<br/>
<span id="more-16647"/></p>
<p>
Indeed the issue with vote counting is one of trust. Our idea is to use computers to assist humans in tallying the votes. But the computers will not be trusted. The goal is to make the number of operations that humans perform of order <img alt="{\log n}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Clog+n%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\log n}"/> where there are <img alt="{n}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n}"/> votes. Even for a national election this is a modest requirement. The surprise, perhaps, is this can be done. </p>
<p>
</p><p/><h2> The Vote-Counting Game </h2><p/>
<p/><p>
Our key insight is to assume that the election is being monitored by two parties—call them Donna and Rachel—who are adversaries. Let us suppose the votes can only be <img alt="{D}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BD%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{D}"/> or <img alt="{R}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R}"/>. Donna wants the count of <img alt="{D}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BD%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{D}"/> to be high, while Rachel wants <img alt="{R}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BR%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{R}"/> to be high, which here is the same as <img alt="{D}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BD%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{D}"/> being low. This is a kind of two-prover model. In complexity theory we know that two provers are more powerful than one prover.</p>
<p>
We insist that D and R play a game. We will explain how the game is played in a moment. The key is that the game—the <i>voting game</i>—has several properties. </p>
<ol>
<li>
At the end of the game, D and R both have made at most order <img alt="{\log n}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Clog+n%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\log n}"/> human operations. <p/>
</li><li>
At the end of the game, D and R may agree on the vote count. <p/>
</li><li>
At the end of the game, if D and R do not agree on the vote count, then one of them will be found to be “cheating” and will be fined a monetary amount.
</li></ol>
<p>
The voting game “solves” the problem of having a humanly checkable election process. The incentive is for D and R to be honest and correct. This precludes either passive error, such as by having incorrect software, or active cheating. If they cheat they may get the fine. If the fine is high enough, that should make D and R strive to be correct.</p>
<p>
Item 2 is critical. We do not claim that if D and R agree that their tally is correct. We only claim that if they agree they should be content with the outcome. This is a key insight and perhaps the most controversial point. If we insisted that D and R only agree when they have the objectively correct count, then it is easy to see they must violate 1: they must take order <img alt="{n}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bn%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{n}"/> steps.</p>
<p>
</p><p/><h3> Structure of the Game and Preparation By the Parties </h3><p/>
<p/><p>
One structural requirement that is a practical necessity anyway is that the vote count is <em>ordered</em> and that the R and D counts follow the same order. We may suppose, say, that the votes are totaled alphabetically by county, then in order of precints within each county, and finally by name in each precinct. Both D and R are required to provide running tallies that respect this order and their computer systems must allow random access to any running subtotal. Producing the tallies of course is a lot of work while the votes are being counted, but this is divided among many people where each side has onsite observers. The act of <em>checking</em> the tallies—and either finding an error or agreeing on the totals—is what we will optimize.</p>
<p/><p>
Let’s consider the tallying of votes. Let 	</p>
<p align="center"><img alt="\displaystyle  v_{1},\dots,v_{n} " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++v_%7B1%7D%2C%5Cdots%2Cv_%7Bn%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  v_{1},\dots,v_{n} "/></p>
<p>be the ordered sequence of votes. Let 	</p>
<p align="center"><img alt="\displaystyle  t_{k} = \sum_{i=1}^{k} v_{i} " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++t_%7Bk%7D+%3D+%5Csum_%7Bi%3D1%7D%5E%7Bk%7D+v_%7Bi%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  t_{k} = \sum_{i=1}^{k} v_{i} "/></p>
<p>be the running tally of the votes—say the count of <img alt="{D}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BD%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{D}"/>. We are not saying D and R can compute this whole sequence infallibly. Of course a computer can compute it, but we cannot trust its answers. What we do is ask D and R to compile their own versions of the tally vector. Let D’s vector be 	</p>
<p align="center"><img alt="\displaystyle  d_{1},\dots,d_{n} " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++d_%7B1%7D%2C%5Cdots%2Cd_%7Bn%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  d_{1},\dots,d_{n} "/></p>
<p>and R’s vector be 	</p>
<p align="center"><img alt="\displaystyle  r_{1},\dots,r_{n}. " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++r_%7B1%7D%2C%5Cdots%2Cr_%7Bn%7D.+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  r_{1},\dots,r_{n}. "/></p>
<p>These vectors are computed by computers owned and run by D and R respectively, using the agreed ordering. Each is responsible for the correctness of their vectors. A critical point is that D and R are responsible for their vectors—we do not assume that they are correct.</p>
<p>
</p><p/><h3> Running The Protocol </h3><p/>
<p/><p>
First, D and R check whether <img alt="{d_{n} = r_{n}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_%7Bn%7D+%3D+r_%7Bn%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_{n} = r_{n}}"/>. If they are equal, it follows that the tally of the election is done. Since D and R are adversaries, if they agree that <img alt="{d_{n}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_%7Bn%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_{n}}"/> is equal to <img alt="{r_{n}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_%7Bn%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_{n}}"/> they agree on the outcome of the election. This is success. Note it is important that in this case: </p>
<blockquote><p><b> </b> <em> <i>The value they agree on is not necessarily the true <img alt="{t_{n}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bt_%7Bn%7D%7D&amp;bg=e8e8e8&amp;fg=000000&amp;s=0" title="{t_{n}}"/>.</i> </em>
</p></blockquote>
<p>This is a critical point. We cannot calculate <img alt="{t_{n}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bt_%7Bn%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{t_{n}}"/> with limited human computations. But if D and R agree that is good enough.</p>
<p>
If <img alt="{d_{n} \neq r_{n}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_%7Bn%7D+%5Cneq+r_%7Bn%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_{n} \neq r_{n}}"/>, then at least one of D and R has made a mistake—or mistakes. That is, some vector is not correct. Note the “mistake” may be a computer error, a human error, or a deliberate error. We do not care which is the case. Nor do we care about finding <em>all</em> mistakes. The goal of the protocol is to give a strong incentive not to make any mistakes and have a process that can check the totals rapidly.</p>
<p>
So take <img alt="{m = \frac{n}{2}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bm+%3D+%5Cfrac%7Bn%7D%7B2%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{m = \frac{n}{2}}"/>, rounded down when needed. D and R then report their running totals <img alt="{d_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_m}"/> and <img alt="{r_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_m}"/>. This uses random access to their tally vectors and so takes constant time. </p>
<ul>
<li>
If <img alt="{d_m \neq r_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_m+%5Cneq+r_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_m \neq r_m}"/>, then D and R know there is an error in the first half. They recurse on that. <p/>
</li><li>
If <img alt="{d_m = r_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_m+%3D+r_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_m = r_m}"/>, then even though these counts may not be correct by themselves, their agreement implies there must be a discrepancy in the second half. D and R recurse on that.
</li></ul>
<p>
This becomes a binary search in which the invariant is that the counts at the low boundary agree and the counts at the high boundary disagree. In about <img alt="{\log_2(n)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Clog_2%28n%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\log_2(n)}"/> steps it gets down to where a discrepancy is found in the tallying of a single vote: one of D and R got it right and the other did not. Whoever did not pays the fine. </p>
<p>
This completes the description of the protocol.  In a more abstract setting this is the same as the discrepancy-finding protocol of Mauricio Karchmer and Avi Wigderson; see their 1990 <a href="https://epubs.siam.org/doi/pdf/10.1137/0403021">paper</a> and this 2017 <a href="https://eccc.weizmann.ac.il/report/2017/129/revision/3/download/">paper</a> by Or Meir.</p>
<p>
</p><p/><h3> Analysis </h3><p/>
<p/><p>
The time analysis is simple. The running time <img alt="{T(n)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BT%28n%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{T(n)}"/> obeys the recursion </p>
<p align="center"><img alt="\displaystyle  T(n) = T(n/2) + O(1) " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++T%28n%29+%3D+T%28n%2F2%29+%2B+O%281%29+&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="\displaystyle  T(n) = T(n/2) + O(1) "/></p>
<p>with solution is <img alt="{T(n) = O(\log n)}" class="latex" src="https://s0.wp.com/latex.php?latex=%7BT%28n%29+%3D+O%28%5Clog+n%29%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{T(n) = O(\log n)}"/>, just as for binary search. </p>
<p>
One fine point is that neither D nor R has any incentive to “lie” by making their tallies deliberately wrong. Suppose <img alt="{d_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_m}"/> is a lie. In the case where <img alt="{r_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_m}"/> differs, the recursion will go there and be one step closer to finding a lie. If Rachel’s vector is correct up to <img alt="{r_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_m}"/>, the discrepancy would never be found with her. If <img alt="{r_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_m}"/> agrees with an incorrect <img alt="{d_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_m}"/>, then that doesn’t matter: there still must be a discrepancy in the upper half, and the search will go there. Thus an honest and correct player cannot be tripped up by dishonesty of the other, while in case <img alt="{d_n \neq r_n}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_n+%5Cneq+r_n%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_n \neq r_n}"/> and <em>both</em> have made mistakes, neither player has a way to know to pin the discovered error on the other party by misreporting <img alt="{d_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_m}"/> or <img alt="{r_m}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_m%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_m}"/>. </p>
<p>
Both the penalty and the swiftness of determining itare incentives to D and R to have good programs. They must rely on a program that each has to determine their values <img alt="{d_{i}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bd_%7Bi%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{d_{i}}"/> and <img alt="{r_{i}}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Br_%7Bi%7D%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{r_{i}}"/>. Both are liable for the correctness of their program. Several aspects make us wonder whether this is a new idea in “checking” of computations:</p>
<ol>
<li>
Humans are able to do the checking. They never do more than order <img alt="{\log n}" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Clog+n%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{\log n}"/> work. <p/>
</li><li>
The result is not a guaranteed correct sum. It is guaranteed that D and R will be forced to agree. <p/>
</li><li>
The players D and R are assumed to work against each other.
</li></ol>
<p>
If there are more than two non-negligible candidates then the details are more complicated—such as needing one “prover” per candidate—but the principles are much the same. More problematic are cases where there might be up to <img alt="{k}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bk%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{k}"/> errors (where the probability of <img alt="{k}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bk%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{k}"/> errors may tail off with higher <img alt="{k}" class="latex" src="https://s0.wp.com/latex.php?latex=%7Bk%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="{k}"/>) and the goal is to find them all. That could be a subject for another post.</p>
<p>
</p><p/><h2> Open Problems </h2><p/>
<p/><p>
In what situations might this protocol be useful? Has anything like it been proposed?</p>
<p>
<b>Update</b> (12:45am ET 2/7): Iowa did finish the count by midnight Thursday in Central Time, but it is open to challenge by any candidate until 1pm ET.  <b>Update:</b> The 1pm challenge deadline has been extended to Monday, so the results will not be final until at least a week later than the vote.  See also this CNN <a href="https://www.cnn.com/2020/02/07/politics/iowa-results-errors/index.html">story</a> about errors in the count.  And this Sunday NYT <a href="https://www.nytimes.com/2020/02/09/us/politics/iowa-democratic-caucuses.html">story</a> on counting errors etc.</p>
<p/><p><br/>
[added updates; added reference to Karchmer-Wigderson protocol.]</p></font></font></div>
    </content>
    <updated>2020-02-07T05:39:40Z</updated>
    <published>2020-02-07T05:39:40Z</published>
    <category term="All Posts"/>
    <category term="Ideas"/>
    <category term="News"/>
    <category term="People"/>
    <category term="Proofs"/>
    <category term="election"/>
    <category term="interactive proofs"/>
    <category term="Iowa caucuses"/>
    <category term="protocols"/>
    <category term="Tony Price"/>
    <category term="voting"/>
    <author>
      <name>RJLipton+KWRegan</name>
    </author>
    <source>
      <id>https://rjlipton.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://rjlipton.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://rjlipton.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://rjlipton.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://rjlipton.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>a personal view of the theory of computation</subtitle>
      <title>Gödel’s Lost Letter and P=NP</title>
      <updated>2020-02-13T12:20:35Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://tcsplus.wordpress.com/?p=387</id>
    <link href="https://tcsplus.wordpress.com/2020/02/06/tcs-talk-wednesday-february-12-albert-atserias-universitat-politecnica-de-catalunya/" rel="alternate" type="text/html"/>
    <title>TCS+ talk: Wednesday, February 12 — Albert Atserias, Universitat Politecnica de Catalunya</title>
    <summary>The next TCS+ talk will take place this coming Wednesday, February 12th at 1:00 PM Eastern Time (10:00 AM Pacific Time, 19:00 Central European Time, 18:00 UTC). Albert Atserias from Universitat Politecnica de Catalunya will speak about “Automating Resolution is NP-Hard” (abstract below). Please make sure you reserve a spot for your group to join […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>The next TCS+ talk will take place this coming Wednesday, February 12th at 1:00 PM Eastern Time (10:00 AM Pacific Time, 19:00 Central European Time, 18:00 UTC). <strong>Albert Atserias</strong> from Universitat Politecnica de Catalunya will speak about “<em>Automating Resolution is NP-Hard</em>” (abstract below).</p>
<p>Please make sure you reserve a spot for your group to join us live by signing up on <a href="https://sites.google.com/site/plustcs/livetalk/live-seat-reservation">the online form</a>. As usual, for more information about the TCS+ online seminar series and the upcoming talks, or to <a href="https://sites.google.com/site/plustcs/suggest">suggest</a> a possible topic or speaker, please see <a href="https://sites.google.com/site/plustcs/">the website</a>.</p>
<blockquote><p>Abstract: We show that it is NP-hard to distinguish CNF formulas that have Resolution refutations of almost linear length from CNF formulas that do not even have weakly exponentially long ones. It follows from this that Resolution is not automatable in polynomial time unless P = NP, or in weakly exponential time unless ETH fails. The proof of this is simple enough that all its ideas can be explained in a talk. Along the way, I will try to explain the process of discovery that led us to the result. This is joint work with Moritz Müller.</p></blockquote>
<p> </p></div>
    </content>
    <updated>2020-02-06T22:05:58Z</updated>
    <published>2020-02-06T22:05:58Z</published>
    <category term="Announcements"/>
    <author>
      <name>plustcs</name>
    </author>
    <source>
      <id>https://tcsplus.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://tcsplus.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://tcsplus.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://tcsplus.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://tcsplus.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A carbon-free dissemination of ideas across the globe.</subtitle>
      <title>TCS+</title>
      <updated>2020-02-13T12:21:09Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-us">
    <id>https://eccc.weizmann.ac.il/report/2020/009</id>
    <link href="https://eccc.weizmann.ac.il/report/2020/009" rel="alternate" type="text/html"/>
    <title>TR20-009 |  Theorems of KKL, Friedgut, and Talagrand via Random Restrictions and Log-Sobolev Inequality | 

	Subhash Khot, 

	Dor Minzer, 

	Muli Safra, 

	Guy Kindler, 

	Esty Kelman</title>
    <summary>We give alternate proofs for three related results in analysis of Boolean functions, namely the KKL
Theorem, Friedgut’s Junta Theorem, and Talagrand’s strengthening of the KKL Theorem. We follow a
new approach: looking at the first Fourier level of the function after a suitable random restriction and
applying the Log-Sobolev inequality appropriately. In particular, we avoid using the hypercontractive inequality
that is common to the original proofs. Our proofs might serve as an alternate, uniform exposition
to these theorems and the techniques might benefit further research.</summary>
    <updated>2020-02-06T21:02:30Z</updated>
    <published>2020-02-06T21:02:30Z</published>
    <source>
      <id>https://eccc.weizmann.ac.il/</id>
      <author>
        <name>ECCC papers</name>
      </author>
      <link href="https://eccc.weizmann.ac.il/" rel="alternate" type="text/html"/>
      <link href="https://example.com/feeds/reports/" rel="self" type="application/atom+xml"/>
      <subtitle>Latest Reports published at https://eccc.weizmann.ac.il</subtitle>
      <title>ECCC - Reports</title>
      <updated>2020-02-13T12:20:26Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://adamsheffer.wordpress.com/?p=5488</id>
    <link href="https://adamsheffer.wordpress.com/2020/02/04/an-algorithms-course-with-minimal-prerequisites/" rel="alternate" type="text/html"/>
    <title>An Algorithms Course with Minimal Prerequisites</title>
    <summary>There are amazing materials for teaching theoretical algorithms courses: excellent books, lecture notes, and online courses. But none of the resources I am familiar with fits the algorithms course I was supposed to prepare. I wanted to teach a course for students who hardly have any prerequisites. My students are non-CS majors (mostly math majors), […]</summary>
    <updated>2020-02-04T20:21:05Z</updated>
    <published>2020-02-04T20:21:05Z</published>
    <category term="Uncategorized"/>
    <author>
      <name>Adam Sheffer</name>
    </author>
    <source>
      <id>https://adamsheffer.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://adamsheffer.wordpress.com/feed/" rel="self" type="application/atom+xml"/>
      <link href="https://adamsheffer.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://adamsheffer.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/>
      <link href="https://adamsheffer.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>Discrete geometry and other typos</subtitle>
      <title>Some Plane Truths</title>
      <updated>2020-02-13T12:21:06Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-US">
    <id>http://ptreview.sublinear.info/?p=1260</id>
    <link href="https://ptreview.sublinear.info/?p=1260" rel="alternate" type="text/html"/>
    <title>News for January 2020</title>
    <summary>The first month of 2020 is behind us, and it’s already looking good! Four papers last month, spanning quantum, graphs, and probability distributions. On Efficient Distance Approximation for Graph Properties, by Nimrod Fiat and Dana Ron (arXiv). In the dense graph (i.e., adjacency-matrix) model, one is given a distance parameter \(\varepsilon\) and granted query access […]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>The first month of 2020 is behind us, and it’s already looking good! Four papers last month, spanning quantum, graphs, and probability distributions.</p>



<p><strong>On Efficient Distance Approximation for Graph Properties</strong>, by Nimrod Fiat and Dana Ron (<a href="https://arxiv.org/abs/2001.01452">arXiv</a>). In the dense graph (i.e., adjacency-matrix) model, one is given a distance parameter \(\varepsilon\) and granted query access to the adjacency matrix of a graph \(G\), and seeks to determine something about the distance of \(G\) to a prespecified property \(\mathcal{P}\) of interest (i.e., the fraction of the matrix that needs to be changed for \(G\) to satisfy the property). <em>Testing</em> requires to distinguish whether that distance is zero, or at least \(\varepsilon\); many results over the past years have shown that many properties can be tested with a number of queries depending only on \(\varepsilon\) (and not on \(n=|G|\). This work focuses on the harder problem of <em>distance estimation</em>, or, equivalently, <em>tolerant</em> testing: that is, estimate this distance up to \(\pm\varepsilon\). The authors introduce a general framework to get distance approximation algorithms from a “complicated” property by decomposing it into simpler properties and using algorithms for those. Applying this framework to a few flagship properties, they then show that \(P_3\)-freeness, induced \(P_4\)-freeness, and cordiality are properties which have <em>efficient</em> distance estimation algorithms (independent of \(n\), and polynomial in \(1/\varepsilon\)).</p>



<p><strong>Minimax Optimal Conditional Independence Testing</strong>, by Matey Neykov, Sivaraman Balakrishnan, and Larry Wasserman (<a href="https://arxiv.org/abs/2001.03039">arXiv</a>). Given i.i.d. draws from a triple \((X,Y,Z)\), how hard is it to check whether \(X \perp Y \mid Z\), that is, “\(X\) and \(Y\) are independent conditioned on \(Z\) (or far from it)?” This is the problem on <em>conditional independence testing</em>,  which was covered <a href="https://ptreview.sublinear.info/?p=939">back in the days</a> for the case where \(X,Y,Z\) are discrete. Well, this new work takes the fight out of the discrete world: extending the results and techniques from the discrete case, it provides optimal bound for the <em>continuous</em> case: where \(Z\) is on \([0,1]\), and then when all three \(X,Y, Z\) are continuous.</p>



<p><strong>How symmetric is too symmetric for large quantum speedups?</strong>, by Shalev Ben-David and Supartha Podder (<a href="https://arxiv.org/abs/2001.09642">arXiv</a>); and <strong>Can graph properties have exponential quantum speedup?</strong>, by Andrew M. Childs and Daochen Wang (<a href="https://arxiv.org/abs/2001.10520">arXiv</a>). Both these works independently study the relation between the (bounded-error) randomized and quantum query complexities of any graph property \(f\), in the dense graph (adjacency-matrix) model. In particular, how much advantage do quantum algorithms provide for those?<br/>As it turns out, not so much: for those functions, both papers show the two quantities are always polynomially related (\(R(f) \leq Q(f) \leq O(R(f)^6))\)) in the dense-graph model. As a corollary, this implies that <em>testing</em> any such property won’t benefit much from quantum (that is, at most polynomially)…. at least in this model. In the adjacency <em>list</em> model (also known as the bounded-degree graph model), the first paper conjectures that exponential query complexity improvements are possible; and the second paper provides an example, establishing it. Altogether, this fully settles an open problem of Ambainis, Childs, and Liu, and Montanaro and de Wolf.</p></div>
    </content>
    <updated>2020-02-03T22:44:59Z</updated>
    <published>2020-02-03T22:44:59Z</published>
    <category term="Monthly digest"/>
    <author>
      <name>Clement Canonne</name>
    </author>
    <source>
      <id>https://ptreview.sublinear.info</id>
      <link href="https://ptreview.sublinear.info/?feed=rss2" rel="self" type="application/atom+xml"/>
      <link href="https://ptreview.sublinear.info" rel="alternate" type="text/html"/>
      <subtitle>The latest in property testing and sublinear time algorithms</subtitle>
      <title>Property Testing Review</title>
      <updated>2020-02-13T01:37:24Z</updated>
    </source>
  </entry>
</feed>
