[{"content": "<![CDATA[<p>Job #53: Yes, that&#8217;s exactly right.  Toffoli&#8217;s argument shows that no finite set of reversible gates is universal without ancillas.  With an infinite set, you can certainly do it: for example, using all the generalized Toffoli gates (Controlled-NOT, Controlled-Controlled-NOT, and so on ad infinitum).</p>\n]]>", "author": "Scott", "published": "2016-12-16 07:13:18+00:00", "title": "By: Scott"}, {"content": "<![CDATA[<p>Is there a known process by which a circuit can be efficiently converted to use zero ancilla bits?</p>\n<p>My understanding is that, without ancilla bits, the order in which gates are executed is not significant &#8211; each gate is strictly reading from the immutable input and flipping output bits &#8211; which makes concurrency and synchronization alot easier.</p>\n<p>And the concept is strange. For example, a sorting algorithm (like MergeSort) converted to use zero ancilla bits could be split up such that each operation is run in parallel? Hard to visualize.</p>\n<p>Also, what is that like O(1) given enough processors? But parallel MergeSort, from what i remember, can&#8217;t do better than logn.</p>\n]]>", "author": "Job", "published": "2016-12-16 08:09:43+00:00", "title": "By: Job"}, {"content": "<![CDATA[<p>Job #55: I already explained that you can&#8217;t convert an arbitrary reversible circuit into one that uses zero ancilla bits.</p>\n<p>And I don&#8217;t know where you got the idea that the order of gates doesn&#8217;t matter in a circuit with no ancilla bits, but it clearly does (try an example and see).</p>\n<p>My, Daniel, and Luke&#8217;s construction uses only O(1) ancilla bits, but plenty of gates, and it need not be parallelizable.</p>\n]]>", "author": "Scott", "published": "2016-12-16 08:27:55+00:00", "title": "By: Scott"}, {"content": "<![CDATA[<blockquote><p>And I don\u2019t know where you got the idea that the order of gates doesn\u2019t matter in a circuit with no ancilla bits, but it clearly does (try an example and see).</p></blockquote>\n<p>Not in a context where input bits are read-only and output bits are write-only. In that case all gates operate on the original immutable input and conditionally flip output bits. The order in which output bits are flipped doesn&#8217;t matter because they&#8217;re never read.</p>\n<p>Essentially, control bits are always connected to input bits and target bits are always connected to output bits.</p>\n<p>I was wondering how universal a gate set under these constraints can actually be.</p>\n]]>", "author": "Job", "published": "2016-12-16 09:47:15+00:00", "title": "By: Job"}, {"content": "<![CDATA[<p>Hey Scott, if you want more CG in the same spirit I definitely recommend checking out Shadertoy. For example this:<br />\n<a href=\"https://www.shadertoy.com/view/llsGW7\" rel=\"nofollow\">https://www.shadertoy.com/view/llsGW7</a></p>\n<p>or this:<br />\n <a href=\"https://www.shadertoy.com/view/XsX3RB\" rel=\"nofollow\">https://www.shadertoy.com/view/XsX3RB</a>.</p>\n<p>There are plenty of impressive effects, procedural landscapes etc. which most of the time are just cool math/coding tricks.</p>\n]]>", "author": "Aspect", "published": "2016-12-16 13:55:13+00:00", "title": "By: Aspect"}, {"content": "<![CDATA[<p>Rhhif #47: Another (and IMHO better) article about this device was linked in <a href=\"http://www.scottaaronson.com/blog/?p=2925#comment-1521445\">this comment</a>, and Scott replied in <a href=\"http://www.scottaaronson.com/blog/?p=2925#comment-1521992\">the next comment</a> on that page. To answer your question, there certainly are no <i>obvious</i> implications to cryptography at the moment. That might change in the future, if tests can demonstrate that this thing can solve large NP-complete problems faster than ordinary computers, but that seems unlikely.</p>\n]]>", "author": "Aula", "published": "2016-12-16 15:19:05+00:00", "title": "By: Aula"}, {"content": "<![CDATA[<p>Scott, after your &#8220;cheap flight&#8221; experience, you may enjoy this:</p>\n<p><a href=\"https://www.youtube.com/watch?v=HPyl2tOaKxM\" rel=\"nofollow\">https://www.youtube.com/watch?v=HPyl2tOaKxM</a></p>\n<p>Nick</p>\n]]>", "author": "<a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/r/Read:Nick.html\">Nick Read</a>", "published": "2016-12-16 16:49:57+00:00", "title": "By: Nick Read"}, {"content": "<![CDATA[<p>Hm, now I&#8217;m wondering if anything is known about the possibility of &#8220;catalytic&#8221; ancilla bits, analogous to this: <a href=\"http://eccc.hpi-web.de/report/2014/053/\" rel=\"nofollow\">http://eccc.hpi-web.de/report/2014/053/</a> (assuming that such a thing makes sense, anyway)</p>\n]]>", "author": "Sniffnoy", "published": "2016-12-16 21:52:19+00:00", "title": "By: Sniffnoy"}, {"content": "<![CDATA[<p>Sniffnoy #61: Actually, yes.  My student Siyao Xu wrote her M.Eng. thesis about reversible circuits.  And one of the things she did there was to draw a distinction between &#8220;ordinary&#8221; ancilla bits, which have to start in a specific state (like 0) and are then returned to that state, and &#8220;catalytic&#8221; ancilla bits (she may have used a different term), which can start in either state and are then returned to that state.  Some reversible circuit constructions require ordinary ancilla bits, but others (especially those only involving affine gates) can be done with catalytic ancillas.</p>\n]]>", "author": "Scott", "published": "2016-12-17 05:21:09+00:00", "title": "By: Scott"}, {"content": "<![CDATA[<p>Interesting!  I might have to look that up&#8230;</p>\n]]>", "author": "Sniffnoy", "published": "2016-12-17 06:11:43+00:00", "title": "By: Sniffnoy"}]