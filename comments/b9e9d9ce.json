[{"content": "<![CDATA[<p>Scott #63:</p>\n<blockquote><p>But for arithmetical questions (e.g., anything that asks about the behavior of a computer program), the situation is very different: there I\u2019d say that we don\u2019t have the option of denying there\u2019s a fact of the matter, unless we\u2019re ready to deny that there\u2019s a fact of the matter about whether 2+2=4, whether there are infinitely many odd numbers, etc., and lapse into total incoherence.</p></blockquote>\n<p>I&#8217;m ready to accept there&#8217;s a fact of the matter about whether 2+2=4, but that still lets me wondering what it means to study the behavior of a Turing machine whose size would exceed the number of atoms in the Universe, or whose polynomial upper bound would exceed this number. In Computer Science like in all finite mathematics, Nature forces us to work within bounded resources. So in this sense, P vs. NP might, indeed, turn out to be an ill-posed problem. What do you think?</p>\n]]>", "author": "Serge", "published": "2014-08-17 23:29:51+00:00", "title": "By: Serge"}, {"content": "<![CDATA[<p>Gil #92<br />\nSorry. &#8220;Easily&#8221; is all relative &#8211; I didn&#8217;t mean it&#8217;s poly but that it&#8217;s obviously much faster than the alternative of doing an explicit counting.<br />\nE.g. for M=25 nodes and N=134 edges, the number of unique connected graphs is computable and is 1099655845868933516685814726984644933338731897533313269778335664  (I don&#8217;t know what&#8217;s the current record for M,N).<br />\nBut, even if you had a magical fast poly-time algo for graph isomorphism and wanted to use it against all possible  graphs (M,N) to count the unique ones by building an explicit list of unique graphs, you probably wouldn&#8217;t be able to go beyond M=9 or 10.</p>\n]]>", "author": "fred", "published": "2014-08-18 00:28:15+00:00", "title": "By: fred"}, {"content": "<![CDATA[<blockquote><p>Out of curiosity, have any non-classical logics (such as this Catu\u1e63ko\u1e6di logic you mention) ever been helpful in solving problems in computer science where it was clear our more conventional logic could not have done the job?</p></blockquote>\n<p>On behalf of the type theorists of the world, the answer is &#8220;yes&#8221;. I don&#8217;t know about this Catu\u1e63ko\u1e6di logic thing, but intuitionistic logic seems far more useful to type theory than classical logic.</p>\n<p>I can&#8217;t speak for topos theorists, but I imagine they&#8217;d say something similar.</p>\n]]>", "author": "Pseudonym", "published": "2014-08-18 00:33:43+00:00", "title": "By: Pseudonym"}, {"content": "<![CDATA[<p>Serge #93:</p>\n<p>Are you ready to accept that there&#8217;s a fact of the matter about there being no largest prime number?</p>\n<p>What about which digit the 10<sup>100000000</sup>th prime number ends in?  Or whether or not the 10<sup>100000000</sup>th decimal digit of &pi; is a 5?</p>\n<p>If you accept that there&#8217;s a fact of the matter about the questions above, then it seems to me that you&#8217;ve already conceded the basic point.</p>\n<p>And if you <i>don&#8217;t</i> accept that there&#8217;s a fact of the matter about these digits, because the obvious program to calculate them wouldn&#8217;t halt before the heat death of the universe &#8230; OK then, what if someone found a more clever program, which computed the digits quickly?  <i>Then</i> would you admit that there had been a fact of the matter all along?</p>\n<p>And even supposing such a program didn&#8217;t exist, doesn&#8217;t your view have the strange implication that there are facts of the matter about the largest prime number that can fit in the observable universe, but no facts of the matter about the very next prime after that?  If the universe had been just slightly larger, would there then have been a fact of the matter about that next larger prime?  Or if cosmologists announced tomorrow that they&#8217;ve discovered the dark energy is decaying away, so that the observable universe is actually infinite, would you <i>then</i> say there are facts of the matter about all the infinitely many primes?  (Assuming you agree that there are, indeed, infinitely many primes?)</p>\n]]>", "author": "Scott", "published": "2014-08-18 01:06:54+00:00", "title": "By: Scott"}, {"content": "<![CDATA[<p>Scott #96<br />\nI see &#8211; one should consider the computational cost associated with every pair (N,P), where N is a natural and P is a certain property.<br />\nSome properties (like the final digit of kth prime) of N depend on the entire full &#8220;chain&#8221; of naturals that precede it &#8211; a big number is viewed as the result a long computation that can&#8217;t be compressed: 1->3->5->7->11->&#8230;<br />\nFor some other properties (like evenness), the chain can be folded/shortened &#8211; a big number in this case is really just like going round and round a finite set of elements: 0->1->0->1->0->1->..</p>\n<p>So, even though the 10^10000000 th prime does indeed end with a 5 or not, for all intents and purposes, it&#8217;s beyond our reach.<br />\nDo mathematical objects exist independently of us discovering (computing) them?</p>\n]]>", "author": "fred", "published": "2014-08-18 02:53:42+00:00", "title": "By: fred"}, {"content": "<![CDATA[<p>Here&#8217;s a number-theoretic question in the same general class as the questions that Scott asks in #96&nbsp;&hellip; but harder (as it seems to me)&nbsp;&hellip; and more obviously complexity-theoretic.</p>\n<p><b>Definition</b>&nbsp; We say that a real number \\(r\\) is \\(P\\)-real with respect to runtime exponent \\(k\\) if there exists a Turing Machine \\(\\text{TM}( r)\\) that outputs \\(n\\) digits of \\(r\\) in time \\(\\mathcal{O}(n^k)\\).</p>\n<p><b>Question</b>&nbsp; Does ZFC suffice to partially order the \\(P\\)-reals with respect to \\(k( r) = \\min_{\\,\\text{TM}( r)}k\\)?</p>\n<p>Questions like this are (as far as I know) both open and difficult. They remind us of Klein&#8217;s Maxim:<br />\n<blockquote><b>Klein&#8217;s Maxim</b>&nbsp; Everyone knows what a curve is, until he has studied enough mathematics to become confused through the countless number of possible exceptions.</p></blockquote>\n<p>If Klein&#8217;s Maxim is true of curves, how much more true is it of runtime exponents?</p>\n]]>", "author": "<a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/SIdles:John.html\">John SIdles</a>", "published": "2014-08-18 04:37:34+00:00", "title": "By: John SIdles"}, {"content": "<![CDATA[<p>fred #97:</p>\n<ul>So, even though the 10^10000000 th prime does indeed end with a 5 or not, for all intents and purposes, it\u2019s beyond our reach.</ul>\n<p>First of all, no prime except 5 ends in a 5 &#8212; otherwise 5 would divide it!! <img src=\"http://www.scottaaronson.com/blog/wp-includes/images/smilies/icon_biggrin.gif\" alt=\":-D\" class=\"wp-smiley\" />   I guess that one <i>wasn&#8217;t</i> beyond our reach after all.</p>\n<p>Of course, we could instead ask whether the 10<sup>10000000</sup> prime ends in a 3.  Even then, as I pointed out in my comment, no one has ruled out the possibility that there&#8217;s a fast algorithm to decide such questions.  Maybe there isn&#8217;t, but the mere <i>possibility</i> that an algorithm exists should make us hesitant to philosophize about such things being &#8220;forever beyond our reach.&#8221;  (Remember Comte philosophizing about how the chemical composition of the stars was forever beyond humans&#8217; reach, a few years before spectral analysis was first used to resolve starlight into hydrogen and helium.)</p>\n<ul>Do mathematical objects exist independently of us discovering (computing) them?</ul>\n<p>If you want to say that 17 didn&#8217;t &#8220;exist&#8221; before anyone named it, then I personally don&#8217;t understand why you shouldn&#8217;t go further, and say (for example) that Venus didn&#8217;t exist before anyone noticed it in the sky.  It&#8217;s true that 17 doesn&#8217;t <i>physically</i> exist in the same sense Venus does, but just like Venus, it clearly has properties (e.g., being prime) that you can&#8217;t change by wishing it.  By my own favorite definition of reality&#8212;&#8221;that which doesn&#8217;t go away when you stop believing in it&#8221;&#8212;this feature would imply that 17 is real.</p>\n]]>", "author": "Scott", "published": "2014-08-18 11:16:40+00:00", "title": "By: Scott"}, {"content": "<![CDATA[<p>Scott #99</p>\n<p>What I mean is that there is some interesting difference between a number which can be described using certain resources and a number which can&#8217;t be described using the same resources. Not whether &#8220;17&#8243; has ever been described or not, but whether we can indeed describe it (by counting on our fingers, or by using a Cray, etc).<br />\nSeems to me that complexity theory is about studying the resources needed to carry out the math:</p>\n<p>Given a finite amount of resources R (finite amount of matter, time, space, energy, information propagation limit, etc), for a given property one can only describe/reach/compute a finite set of naturals, and all the others are unreachable beyond a sort of computational horizon.</p>\n<p>And isn&#8217;t the essence of P!=NP and such questions really about how that finite set grows as a function of the resources?<br />\nYou guys also look for shortcuts through the computational horizon, or ask theoretical questions about altering the limitation of the resources (with &#8220;oracles&#8221;?).<br />\nAnd the P!=NP quest is itself subjected to the same limitations as any other property of the naturals.<br />\n(this is probably all very obvious, sorry&#8230; I&#8217;m no mathematician or complexity theorist, just an average engineer).</p>\n]]>", "author": "fred", "published": "2014-08-18 12:58:23+00:00", "title": "By: fred"}, {"content": "<![CDATA[<p>John Sidles #98: I can answer your question, although given past experience, I&#8217;m worried that you&#8217;re going to invent some after-the-fact reason for not counting my answer as an answer.</p>\n<p>You ask whether ZFC can &#8220;partially order&#8221; the polynomial-time computable reals, with respect to exact polynomial bounds of the fastest TMs that compute them.</p>\n<p>Well, it&#8217;s trivial to &#8220;partially order&#8221; this or any other set: just output that r is computable faster than s whenever you can prove that fact, and refuse to answer whenever you can&#8217;t!</p>\n<p>So to make the question more interesting, let me assume that you meant &#8220;totally order.&#8221;  There&#8217;s still an ambiguity in your question (the same ambiguity, I recall, that marred several of your MathOverflow and CS StackExchange questions; I see that the many commenters trying to explain this to you had no effect).  Namely, ZFC can only be &#8220;asked&#8221; about particular real numbers by giving it finite descriptions of them.  And ZFC might be able to prove something about a real number r if described in one way, but not be able to prove <i>the same statement about the same real number</i> if r is described differently.</p>\n<p>But, OK, let&#8217;s assume you meant: <i>given two polynomial-time computable real numbers r and s, described&#8212;let&#8217;s say&#8212;by Turing machines to compute them, can ZFC always decide whether one of them is computable faster than the other?</i></p>\n<p>In this case, the answer to your question is no.  Proof: let r=0.r<sub>1</sub>r<sub>2</sub>r<sub>3</sub>&#8230; be any real number in [0,1] such that computing its first n digits requires &Theta;(n<sup>2</sup>) time (such an r is easily produced using the Time Hierarchy Theorem).  Then define s=0.s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>&#8230; by setting s<sub>n</sub>=r<sub>n</sub> if the lexicographically first n ZFC proofs include a proof of 0=1, and s<sub>n</sub>=0 otherwise.  Then assuming ZFC is consistent, we have s=0 and therefore s is computable in linear time.  But since ZFC can&#8217;t prove its consistency, for all it knows s agrees with r after some finite point, and therefore requires quadratic time.  So ZFC can&#8217;t even decide whether s is computable faster than &#8220;0&#8243; (by which I mean, the real number computed by some Turing machine that manifestly outputs 0.00000&#8230;.).</p>\n]]>", "author": "Scott", "published": "2014-08-18 13:28:00+00:00", "title": "By: Scott"}, {"content": "<![CDATA[<blockquote><p><b>Scott</b> observes &#8220;It\u2019s trivial to partially order [the polynomial-time computable reals]: just output that r is computable faster than s whenever you can prove that fact, and refuse to answer whenever you can\u2019t!&#8221;</p></blockquote>\n<p>The history of mathematics shows plainly&nbsp;&mdash; as emphasized by Grothendieck for example&nbsp;&mdash; that &#8220;trivial&#8221; observations can be exceedingly &#8220;interesting&#8221; and even &#8220;useful&#8221;.</p>\n<p><b>Example</b>&nbsp; Relative to &#8220;wild curves&#8221;, smooth curves have many properties that are trivial&nbsp;&hellip; and yet smooth curves are exceedingly interesting and useful.</p>\n<p>Inspired by Scott&#8217;s construction (#101), let \\(P&#8217;\\)-reals be those reals with provable most-efficient polynomial-time runtime exponents, as contrasted with the (larger?) set of \\(P\\)-reals that have most-efficient polynomial-time runtime exponents that are not necessarily provable.  </p>\n<p>Then ZFC naturally sorts (by runtime) the \\(P&#8217;\\)-reals into well-ordered complexity classes, whereas the \\(P\\)-reals cannot be thus sorted (per Scott&#8217;s example).</p>\n<p>Thus relative to \\(P\\)-reals, the complexity-class sorting of the \\(P&#8217;\\)-reals is formally trivial&nbsp;&hellip; and yet for practical computational purposes that same sorting is of course exceedingly interesting and useful.</p>\n<p><b>Candidate <i>MathOverflow</i> Question</b>&nbsp; Can ZFC or any of its extensions exhibit a list of digits of <i>any</i> of the reals in \\(P\\backslash P&#8217;\\)?  If&nbsp;yes, provide an algorithm that explicitly exhibits the digits of at least one of the reals in \\(P\\backslash P&#8217;\\). If&nbsp;no, give reasons why we ever need to speak of the \\(P\\)-reals at all&nbsp;&hellip; because don&#8217;t  the \\(P&#8217;\\)-reals capture all of the algorithmic structure of the \\(P\\)-reals that we have reason to care about?</p>\n<p>Suggestions for tuning this question to be as interesting as possible are of course welcome&nbsp;&hellip; concrete answers are of course even <i>more</i> welcome.</p>\n<p>Perhaps the answer: &#8220;This question is natural, open, and hard&#8221; is the best that we can muster in light of present mathematical knowledge&nbsp;&hellip; and this answer too is worth appreciating.</p>\n]]>", "author": "<a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Sidles:John.html\">John Sidles</a>", "published": "2014-08-18 15:29:48+00:00", "title": "By: John Sidles"}, {"content": "<![CDATA[<p>John Sidles #102:  P-P&#8217; is simply empty.  Any p-time algorithm can be made into a provably p-time algorithm, by adding a timer to the Turing machine.  (The technical details are a bit lengthy for a blog comment, but hopefully that is intuitive enough.)  So P&#8217; already covers all functions that could be computed in p-time.</p>\n]]>", "author": "<a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/G:Luke.html\">Luke G</a>", "published": "2014-08-19 01:29:41+00:00", "title": "By: Luke G"}, {"content": "<![CDATA[<p>LukeG (#103), your post outlines (what are called) <i>polylimiter</i> and <i>polynomially clocked</i> reductions, which are discussed at-length in the <i>TCS StackExchange</i> community wiki &#8220;Does P contain languages whose existence is independent of PA or ZFC?&#8221;, specifically in comments by Peter Shor, Sasho Nikolov, Luca Trevisan, and Timothy Chow (the wiki provides links).  </p>\n<p>The computational intuition is easy to summarize: it&#8217;s not computationally natural (as the wiki says) to &#8220;mask cryptic computations by overlaying a computationally superfluous epi-computation&#8221; </p>\n<p>The practical intuition is simple too: when a software engineer is given the source code to an algorithm, and that algorithm is claimed to be \\(\\mathcal{O}(n^2)\\), and the engineer is asked to verify and certify the claimed quadratic runtime, it&#8217;s poor practice to ignore the algorithmic structure of the source code, and instead wrap the code in a quadratic time-limiter, so as to rigorously certify the claimed runtime.  The real-world problems associated to software verification are <i>much</i> harder than <i>that</i>, and complexity-theory formalisms that respect these difficulties are preferred (by engineers if not logicians).</p>\n<p>You are entirely right too, to appreciate that &#8220;the technical details are a bit lengthy for a blog comment.&#8221;</p>\n]]>", "author": "<a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Sidles:John.html\">John Sidles</a>", "published": "2014-08-19 13:17:13+00:00", "title": "By: John Sidles"}]