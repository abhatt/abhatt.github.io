[{"content": "<![CDATA[<p>Current computations of pi do not use the arctan series. Instead, either highly convergent series based on work of Ramanujan of iterations of type like Gauss&#8217; arithmetic-geometric mean iteration are used.</p>\n<p>There are lots of sites with info about this. Just do a search for &#8220;computing pi&#8221;.</p>\n]]>", "author": "<a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/c/Cohen:Martin.html\">Martin Cohen</a>", "published": "2014-08-11 22:39:02+00:00", "title": "By: Martin Cohen"}, {"content": "<![CDATA[<p>I&#8217;ve read that Computer Algebra systems like Mathematica have many digits of pi recorded in their software since this is a common way in which people compare the speed of said programs.  So I would venture to say that Mathematica 10 didn&#8217;t do any calculations; it just looked it up your answer in a table.</p>\n]]>", "author": "<a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Hanusa:Chris.html\">Chris Hanusa</a>", "published": "2014-08-11 23:19:29+00:00", "title": "By: Chris Hanusa"}, {"content": "<![CDATA[<p>Thanks for your interesting article on the lifetime labor of a (human) computer. A search led me to Wikipedia&#8217;s fascinating list of formulas for <a href=\"http://en.wikipedia.org/wiki/Computing_%CF%80\" rel=\"nofollow\"> computing pi</a>.</p>\n]]>", "author": "Peter", "published": "2014-08-12 09:15:21+00:00", "title": "By: Peter"}, {"content": "<![CDATA[<p>What a great read, thank you for sharing!</p>\n]]>", "author": "Jason", "published": "2014-08-12 18:52:57+00:00", "title": "By: Jason"}, {"content": "<![CDATA[<p>Ever since I mentioned Shanks and his 707 digits in a review of Mathematica 1.0, I have wondered about the possibility of such benchmark-rigging.</p>\n<p>Here are some timings recorded in Mathematica 10.0, as the program computed (or not?!) 10^<em>i</em> digits of pi for 0 &le; <em>i</em> &le; 8: </p>\n<pre>Table[{10^i, Timing[N[Pi, 10^i]][[1]]}, {i, 0, 8}]\n  {{1, 0.000053},\n   {10, 0.000021},\n   {100, 0.000033},\n   {1000, 0.000105},\n   {10000, 0.001292},\n   {100000, 0.026601},\n   {1000000, 0.430528},\n   {10000000, 6.249267},\n   {100000000, 98.862143}}</pre>\n<p>For fewer than about 1,000 digits, the results look like noise; there&#8217;s no clear correlation between precision and time. That outcome would be consistent with your hypothesis that we&#8217;re just doing table lookup in this range. But it&#8217;s also consistent with the hypothesis that the computation is so fast that the overall time is dominated by OS and UI events, or other overhead. Without access to the source code, it&#8217;s hard to know which.</p>\n<p>We <em>do</em> have the source code for <a href=\"http://www.sagemath.org/\" rel=\"nofollow\">Sage</a>, the open-source mathematics system. Here&#8217;s what I get running the equivalent command there:</p>\n<pre>for i in range(9):\n  [(10**i, \n   '{:.6f}'.format(timeit('n(pi, digits='+str(10**i)+')', \n      seconds=True, number=1)))]\n[(1, '0.000019')]\n[(10, '0.000021')]\n[(100, '0.000024')]\n[(1000, '0.000105')]\n[(10000, '0.004632')]\n[(100000, '0.245613')]\n[(1000000, '3.692356')]\n[(10000000, '55.570486')]\n[(100000000, '1012.650426')]</pre>\n<p>The times for large numbers of digits are about an order of magnitude slower, but for fewer than 1,000 digits the results look very similar to those of Mathematica. In Sage I&#8217;m pretty sure there&#8217;s no precomputed value being looked up. Sage apparently uses the <a href=\"http://mpmath.org/\" rel=\"nofollow\">mpmath</a> package for computing constants and elementary functions. The mpmath <a href=\"https://github.com/fredrik-johansson/mpmath\" rel=\"nofollow\">source code</a> (see libelefun.py) suggests there&#8217;s some caching or memoizing of results as they are computed, but not lookup from a pre-baked table.</p>\n<p>As a point of interest, here&#8217;s the mpmath docstring on pi computations:</p>\n<pre>For computation of pi, we use the Chudnovsky series:\n\n             oo\n             ___        k\n      1     \\       (-1)  (6 k)! (A + B k)\n    ----- =  )     -----------------------\n    12 pi   /___               3  3k+3/2\n                    (3 k)! (k!)  C\n            k = 0\n\nwhere A, B, and C are certain integer constants. This series adds roughly\n14 digits per term. Note that C^(3/2) can be extracted so that the\nseries contains only rational terms. This makes binary splitting very\nefficient.\n\nThe recurrence formulas for the binary splitting were taken from\n<a href=\"ftp://ftp.gmplib.org/pub/src/gmp-chudnovsky.c\" rel=\"nofollow\">ftp://ftp.gmplib.org/pub/src/gmp-chudnovsky.c</a>\n\nPreviously, Machin's formula was used at low precision and the AGM iteration\nwas used at high precision. However, the Chudnovsky series is essentially as\nfast as the Machin formula at low precision and in practice about 3x faster\nthan the AGM at high precision (despite theoretically having a worse\nasymptotic complexity), so there is no reason not to use it in all cases.</pre>\n<p>(Disclaimer: I don&#8217;t know my way around the Sage or mpmath source files, and I may have misunderstood what&#8217;s going on.)</p>\n]]>", "author": "<a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/h/Hayes:Brian.html\">Brian Hayes</a>", "published": "2014-08-12 20:54:36+00:00", "title": "By: Brian Hayes"}]