[{"content": "<![CDATA[<p>Scott #94<br />\nI just want you to describe to me what some world is like where 2+3 is not 5</p>\n<p>The problem is that one needs to define precisely the meaning of the symbols 2, 3, 5, and =.<br />\nI don&#8217;t think it&#8217;s as obvious as it seems.<br />\nIs math nothing more than the power of writing symbols on paper?<br />\nOr is math supposed to simply map itself to real world constructs?<br />\nOne could imagine a world where 2+3 = 5 just isn&#8217;t &#8216;useful&#8217;.<br />\nImagine a world where the *only* objects are &#8220;blobs&#8221; that can only exist as a singleton (1), in &#8220;pair state&#8221; (2), or in &#8220;triplet state&#8221; (3), &#8220;quadruplet&#8221; (4)<br />\n1+1 = 2<br />\n1+2 = 3<br />\n1+3 = 4<br />\nbut<br />\n2+3 != 5<br />\n1+4 != 5</p>\n<p>so there&#8217;s no such thing as &#8220;bringing together&#8221; or &#8220;observing&#8221; a pair and a triplet together.  It&#8217;s an ill-defined situation.</p>\n<p>Maybe because quintuplets just don&#8217;t exist &#8211; bringing 2 or 3 together would create some sort of annihilation of the entire universe. </p>\n<p>Or a bit like how people can only visualize distinct groups of 2 or 3 objects in their &#8220;mind&#8217;s eye&#8221;, but are incapable to visualize a group of 5 objects &#8220;at once&#8221;.</p>\n]]>", "author": "fred", "published": "2017-09-19 14:57:14+00:00", "title": "By: fred"}, {"content": "<![CDATA[<p>#99:</p>\n<blockquote><p>Indeed the Completeness Theorem can be interpreted as saying precisely that the nonstandard integers are \u201cnothing more than that,\u201d spandrels that have to exist by the mere fact of ZF+Not(Con(ZF)) and so forth being consistent.</p></blockquote>\n<p>You don&#8217;t need the incompleteness theorems to get nonstandard models. You can get a nonstandard model of \u2115 simply by <a href=\"https://en.wikipedia.org/wiki/Ultraproduct\" rel=\"nofollow\">taking the set of sequences of elements of \u2115 and dividing it by the equivalence relation which holds between two sequences if the set of indices on which they agree is a member of some fixed non-principal ultrafilter</a>. In such a model, Con(ZF) will have the same truth-value as in the model from which you&#8217;ve started, and yet it will have members like the equivalence class containing (0, 1, 2, 3, 4, 5, 6, 7, &#8230;), which doesn&#8217;t correspond to any &#8216;ordinary&#8217; integer.</p>\n<p>Nonstandard models aren&#8217;t there merely because we can&#8217;t prove that certain formal systems are consistent; they exist because we can&#8217;t even define what it means for something to be finite.</p>\n]]>", "author": "Anonymous", "published": "2017-09-19 15:25:14+00:00", "title": "By: Anonymous"}, {"content": "<![CDATA[<p>Scott #140<br />\n&#8220;In a finite field, [&#8230;] it doesn\u2019t really make sense to ask whether one field element is \u201cgreater\u201d or \u201cless\u201d than another one, any more than it makes sense to ask whether 11pm is earlier or later than 3am \u2014 you can reach 3am from 11pm by going to the past or going to the future!.&#8221;</p>\n<p>But it does make sense once you start considering &#8220;objects&#8221; living in the fields.</p>\n<p>E.g. spans of time.<br />\nYou can certainly imagine working for 5 hours, from 6pm till 11pm.<br />\nOr working 5 hours from 11pm till 4am, and then it makes sense to say that &#8220;4am is later than 11pm&#8221;.<br />\nAnd it&#8217;s not the same as working from 4am till 11pm (a span of 7 hours), in which case 11pm is &#8220;later&#8221; than 4am.</p>\n<p>Or take a boat sailing the earth (a finite field), you need to be able to distinguish its bow from its rear (i.e. distinguish a boat that&#8217;s 100m long from one that has a length of a great circle &#8211; 100m&#8230; or a boat having a length of 3 great circles &#8211; 100m, i.e. wrapping around three times).</p>\n]]>", "author": "fred", "published": "2017-09-19 15:31:22+00:00", "title": "By: fred"}, {"content": "<![CDATA[<p>I still haven&#8217;t managed to carefully read this whole interesting post, but a few comments:</p>\n<p>1) Giuseppe Peano&#8217;s axioms introduced in the 19th century were not the same thing as what we now call PA.  Peano&#8217;s axioms used a single induction axiom that quantified over formulas, so we&#8217;d now consider it to be given in second-order logic.  I don&#8217;t know when the first-order theory PA was introduced but my guess is no earlier than the 1920s.  It would be interesting to look up the history and I might try to do that.</p>\n<p>2) Even if one says the nth-level BB(k) is a definite number for all finite n and k, it gets messy if n is a transfinite ordinal, because of different possible codings of them.  You might like the article:</p>\n<p><a href=\"https://xorshammer.com/2009/03/23/what-happens-when-you-iterate-godels-theorem/\" rel=\"nofollow\">https://xorshammer.com/2009/03/23/what-happens-when-you-iterate-godels-theorem/</a></p>\n<p>if you haven&#8217;t seen it.  It explains the natural progression from PA through 2nd order arithmetic, ending up with set theory.</p>\n<p>IMHO it&#8217;s reasonable to say that every Turing machine either halts or doesn&#8217;t (i.e. every Pi-0-1 sentence has a truth value) while not saying the same of sentences with 100s of alternating quantifiers (what can that mean?).  Or that PA is unconvincing because the induction axioms say things like &#8220;if phi(0) and (phi(n)=>phi(n+1)) then forall n. phi(n)&#8221; which presumes that all those n&#8217;s actually exist.  Of course 0 exists (an axiom says so), as does S0, SS0, etc., but many formulas denoting integers can never be reached that way.  That viewpoint is called &#8220;predicative arithmetic&#8221; and was mostly done by Edward Nelson, who wrote a book and a bunch of articles about it.  His predicative system was weaker than PRA but stronger than Robinson&#8217;s Q, and he was still able to encode most interesting math in it.</p>\n<p>4. Shachaf Ben-Kiki once joked that ultrafinitists are mathematicians who believe that Peano arithmetic goes from 1 to 88 ;-).</p>\n]]>", "author": "asdf", "published": "2017-09-20 07:13:50+00:00", "title": "By: asdf"}, {"content": "<![CDATA[<p>Re fred #153:</p>\n<p>> Is math nothing more than the power of writing symbols on paper?</p>\n<p>No, but writing symbols on paper is a rather accurate model that most of us humans can handle easily.  Writing symbols with chalk on a blackboard is closer to real math, but has some practical difficulties for humans.  Real math in the original of the Book is written on a medium that is entirely unusable by humans, and that may even be unimaginable for them.  Humans can only ever read imperfect copies of parts of the Book in various forms more convenient for them.</p>\n]]>", "author": "jonas", "published": "2017-09-20 09:53:58+00:00", "title": "By: jonas"}, {"content": "<![CDATA[<p>jonas #157, Thou shall not take any other Book before me, eh?</p>\n]]>", "author": "Atreat", "published": "2017-09-20 13:26:13+00:00", "title": "By: Atreat"}, {"content": "<![CDATA[<p>jonas #157</p>\n<p>I was thinking about Formal Grammars, i.e. symbols + replacement rules (<a href=\"https://en.wikipedia.org/wiki/Formal_grammar\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Formal_grammar</a>).<br />\nDoesn&#8217;t that cover (most?) of mathematics?</p>\n]]>", "author": "fred", "published": "2017-09-20 15:00:34+00:00", "title": "By: fred"}, {"content": "<![CDATA[<p>@ Walter #93 and Scott #96</p>\n<p>It&#8217;s Matteo, the organizer of the Festival. Thanks again Scott for your great contributions. You shouldn&#8217;t be worried about the language barrier or the difficulty of the talk: the point we try to make at Festivaletteratura is that we shouldn&#8217;t downplay the audience. We want them to confront with scientific thinking in all of its complexity rather than with the sort of easily-digestible metaphors that infest scientific popularisation. And thanks Walter for being a Festival supporter. About the books, a short apology: unfortunately the Festival\u2019s library is not used to dealing with academic publishers, and apparently there are complications with orders involving this kind of products.</p>\n]]>", "author": "tomate", "published": "2017-09-20 18:47:24+00:00", "title": "By: tomate"}, {"content": "<![CDATA[<p>@Jonas #110<br />\nI think I should clarify what I meant in comment #51. The goal of making PRG is to have a deterministic algorithm that takes a small random seed and output a string that &#8220;looks random&#8221; to an adversary. One possible way to do this is to build a generator that &#8220;behaves like&#8221; it has a huge seed even though the actual seed is small, say like 128 bits. So the intuition here is to show that it is infeasible to invert the generator due to an algorithmic information theoretic argument: the program size complexity of the generator is way larger than the string of output bits of the generator by a constant factor, so no algorithm can succeed in describing the internal state of the generator using the output bits.</p>\n]]>", "author": "William Hird", "published": "2017-09-21 04:25:23+00:00", "title": "By: William Hird"}, {"content": "<![CDATA[<p>William #161: The trouble is, you always assume the inversion algorithm knows the code of the generator.  Anything that&#8217;s not known to the inverter is part of the seed, by definition.  And the seed is shorter than the output string.</p>\n]]>", "author": "Scott", "published": "2017-09-21 05:26:47+00:00", "title": "By: Scott"}, {"content": "<![CDATA[<p>Scott#50, &#8220;Have any examples of ZFC extensions with conflicting arithmetical theorems seriously been proposed by anyone?&#8221;</p>\n<p>Sure, depending on what you mean by serious.  ZFC+Not(CON(ZFC)) conflicts with ZFC+&#8221;there exists an inaccessible cardinal&#8221;, since the existence of the inaccessible cardinal means ZFC has a model and is therefore consistent.</p>\n]]>", "author": "asdf", "published": "2017-09-21 05:49:35+00:00", "title": "By: asdf"}, {"content": "<![CDATA[<p>@Scott #162:<br />\nThe generator is self-keying, in the same vein as an autokey cipher. It re-seeds itself every clock cycle , the actual generation of output bits is a fractional (tiny) subroutine of the main algorithm. Yes the actual seed is smaller than the output but the &#8220;virtual seed&#8221; is always larger, there is a phase transition that takes place , I don&#8217;t want to give any details of how this would be done here, maybe in the future I will give a link on your blog to the actual design, after it&#8217;s well vetted, maybe, we&#8217;ll see \ud83d\ude09</p>\n]]>", "author": "William Hird", "published": "2017-09-21 06:05:24+00:00", "title": "By: William Hird"}, {"content": "<![CDATA[<p>As a humorous side note(hopefully) has anyone noticed that Trump&#8217;s new chief of staff Kelley looks like the guy who played the head of the Praetorian Guard in the movie &#8220;Gladiator&#8221; ? At the end of the movie he kinda lets the emperor be killed by Russell Crowe and Rome kinda sorta becomes a democracy again. Is life about to imitate art ?</p>\n]]>", "author": "William Hird", "published": "2017-09-21 07:08:10+00:00", "title": "By: William Hird"}, {"content": "<![CDATA[<p>asdf #163: I&#8217;m obviously well aware that ZF+Not(Con(ZF)) proves false arithmetical theorems!  I meant two extensions that prove conflicting arithmetical statements and that are both &#8220;natural,&#8221; in the sense that both have mathematicians who advocate them as likely to be arithmetically sound.  And let&#8217;s exclude cases like ZF+(NEXP=coNEXP) and ZF+(NEXP&ne;coNEXP), where pretty much everyone hopes that mathematical advances will ultimately reveal one extension or the other to be inconsistent: I only want cases where experts generally agree that the two extensions are both consistent, and disagree only on which is arithmetically sound.</p>\n]]>", "author": "Scott", "published": "2017-09-21 11:21:50+00:00", "title": "By: Scott"}, {"content": "<![CDATA[<p>William #164: A pseudorandom generator that&#8217;s secure for &#8220;trivial counting reasons&#8221; that have nothing to do with computational intractability, is just as impossible as a lossless compression program that works on random input (i.e., whose success has nothing to do with exploiting regularities in the data).  There&#8217;s no amount of playing around with the definitions of words that can change this.</p>\n<p>But let&#8217;s end this particular exchange here, since no convergence seems to be happening&#8230;</p>\n]]>", "author": "Scott", "published": "2017-09-21 11:27:07+00:00", "title": "By: Scott"}]